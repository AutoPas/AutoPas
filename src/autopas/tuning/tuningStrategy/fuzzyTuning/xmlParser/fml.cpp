// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "fml.h"

#include <xsd/cxx/pre.hxx>

// FuzzySystemType
//

const FuzzySystemType::knowledgeBase_type &FuzzySystemType::knowledgeBase() const { return this->knowledgeBase_.get(); }

FuzzySystemType::knowledgeBase_type &FuzzySystemType::knowledgeBase() { return this->knowledgeBase_.get(); }

void FuzzySystemType::knowledgeBase(const knowledgeBase_type &x) { this->knowledgeBase_.set(x); }

void FuzzySystemType::knowledgeBase(::std::unique_ptr<knowledgeBase_type> x) { this->knowledgeBase_.set(std::move(x)); }

const FuzzySystemType::mamdaniRuleBase_sequence &FuzzySystemType::mamdaniRuleBase() const {
  return this->mamdaniRuleBase_;
}

FuzzySystemType::mamdaniRuleBase_sequence &FuzzySystemType::mamdaniRuleBase() { return this->mamdaniRuleBase_; }

void FuzzySystemType::mamdaniRuleBase(const mamdaniRuleBase_sequence &s) { this->mamdaniRuleBase_ = s; }

const FuzzySystemType::name_type &FuzzySystemType::name() const { return this->name_.get(); }

FuzzySystemType::name_type &FuzzySystemType::name() { return this->name_.get(); }

void FuzzySystemType::name(const name_type &x) { this->name_.set(x); }

void FuzzySystemType::name(::std::unique_ptr<name_type> x) { this->name_.set(std::move(x)); }

// KnowledgeBaseType
//

const KnowledgeBaseType::fuzzyVariable_sequence &KnowledgeBaseType::fuzzyVariable() const {
  return this->fuzzyVariable_;
}

KnowledgeBaseType::fuzzyVariable_sequence &KnowledgeBaseType::fuzzyVariable() { return this->fuzzyVariable_; }

void KnowledgeBaseType::fuzzyVariable(const fuzzyVariable_sequence &s) { this->fuzzyVariable_ = s; }

// FuzzyVariableType
//

const FuzzyVariableType::fuzzyTerm_sequence &FuzzyVariableType::fuzzyTerm() const { return this->fuzzyTerm_; }

FuzzyVariableType::fuzzyTerm_sequence &FuzzyVariableType::fuzzyTerm() { return this->fuzzyTerm_; }

void FuzzyVariableType::fuzzyTerm(const fuzzyTerm_sequence &s) { this->fuzzyTerm_ = s; }

const FuzzyVariableType::name_type &FuzzyVariableType::name() const { return this->name_.get(); }

FuzzyVariableType::name_type &FuzzyVariableType::name() { return this->name_.get(); }

void FuzzyVariableType::name(const name_type &x) { this->name_.set(x); }

void FuzzyVariableType::name(::std::unique_ptr<name_type> x) { this->name_.set(std::move(x)); }

const FuzzyVariableType::defuzzifier_type &FuzzyVariableType::defuzzifier() const { return this->defuzzifier_.get(); }

FuzzyVariableType::defuzzifier_type &FuzzyVariableType::defuzzifier() { return this->defuzzifier_.get(); }

void FuzzyVariableType::defuzzifier(const defuzzifier_type &x) { this->defuzzifier_.set(x); }

void FuzzyVariableType::defuzzifier(::std::unique_ptr<defuzzifier_type> x) { this->defuzzifier_.set(std::move(x)); }

const FuzzyVariableType::defuzzifier_type &FuzzyVariableType::defuzzifier_default_value() {
  return defuzzifier_default_value_;
}

const FuzzyVariableType::accumulation_type &FuzzyVariableType::accumulation() const {
  return this->accumulation_.get();
}

FuzzyVariableType::accumulation_type &FuzzyVariableType::accumulation() { return this->accumulation_.get(); }

void FuzzyVariableType::accumulation(const accumulation_type &x) { this->accumulation_.set(x); }

void FuzzyVariableType::accumulation(::std::unique_ptr<accumulation_type> x) { this->accumulation_.set(std::move(x)); }

const FuzzyVariableType::accumulation_type &FuzzyVariableType::accumulation_default_value() {
  return accumulation_default_value_;
}

const FuzzyVariableType::scale_optional &FuzzyVariableType::scale() const { return this->scale_; }

FuzzyVariableType::scale_optional &FuzzyVariableType::scale() { return this->scale_; }

void FuzzyVariableType::scale(const scale_type &x) { this->scale_.set(x); }

void FuzzyVariableType::scale(const scale_optional &x) { this->scale_ = x; }

void FuzzyVariableType::scale(::std::unique_ptr<scale_type> x) { this->scale_.set(std::move(x)); }

const FuzzyVariableType::domainleft_type &FuzzyVariableType::domainleft() const { return this->domainleft_.get(); }

FuzzyVariableType::domainleft_type &FuzzyVariableType::domainleft() { return this->domainleft_.get(); }

void FuzzyVariableType::domainleft(const domainleft_type &x) { this->domainleft_.set(x); }

const FuzzyVariableType::domainright_type &FuzzyVariableType::domainright() const { return this->domainright_.get(); }

FuzzyVariableType::domainright_type &FuzzyVariableType::domainright() { return this->domainright_.get(); }

void FuzzyVariableType::domainright(const domainright_type &x) { this->domainright_.set(x); }

const FuzzyVariableType::defaultValue_type &FuzzyVariableType::defaultValue() const {
  return this->defaultValue_.get();
}

FuzzyVariableType::defaultValue_type &FuzzyVariableType::defaultValue() { return this->defaultValue_.get(); }

void FuzzyVariableType::defaultValue(const defaultValue_type &x) { this->defaultValue_.set(x); }

FuzzyVariableType::defaultValue_type FuzzyVariableType::defaultValue_default_value() { return defaultValue_type(0.0F); }

const FuzzyVariableType::type_type &FuzzyVariableType::type() const { return this->type_.get(); }

FuzzyVariableType::type_type &FuzzyVariableType::type() { return this->type_.get(); }

void FuzzyVariableType::type(const type_type &x) { this->type_.set(x); }

void FuzzyVariableType::type(::std::unique_ptr<type_type> x) { this->type_.set(std::move(x)); }

const FuzzyVariableType::type_type &FuzzyVariableType::type_default_value() { return type_default_value_; }

// FuzzyTermType
//

const FuzzyTermType::rightLinearShape_optional &FuzzyTermType::rightLinearShape() const {
  return this->rightLinearShape_;
}

FuzzyTermType::rightLinearShape_optional &FuzzyTermType::rightLinearShape() { return this->rightLinearShape_; }

void FuzzyTermType::rightLinearShape(const rightLinearShape_type &x) { this->rightLinearShape_.set(x); }

void FuzzyTermType::rightLinearShape(const rightLinearShape_optional &x) { this->rightLinearShape_ = x; }

void FuzzyTermType::rightLinearShape(::std::unique_ptr<rightLinearShape_type> x) {
  this->rightLinearShape_.set(std::move(x));
}

const FuzzyTermType::leftLinearShape_optional &FuzzyTermType::leftLinearShape() const { return this->leftLinearShape_; }

FuzzyTermType::leftLinearShape_optional &FuzzyTermType::leftLinearShape() { return this->leftLinearShape_; }

void FuzzyTermType::leftLinearShape(const leftLinearShape_type &x) { this->leftLinearShape_.set(x); }

void FuzzyTermType::leftLinearShape(const leftLinearShape_optional &x) { this->leftLinearShape_ = x; }

void FuzzyTermType::leftLinearShape(::std::unique_ptr<leftLinearShape_type> x) {
  this->leftLinearShape_.set(std::move(x));
}

const FuzzyTermType::piShape_optional &FuzzyTermType::piShape() const { return this->piShape_; }

FuzzyTermType::piShape_optional &FuzzyTermType::piShape() { return this->piShape_; }

void FuzzyTermType::piShape(const piShape_type &x) { this->piShape_.set(x); }

void FuzzyTermType::piShape(const piShape_optional &x) { this->piShape_ = x; }

void FuzzyTermType::piShape(::std::unique_ptr<piShape_type> x) { this->piShape_.set(std::move(x)); }

const FuzzyTermType::triangularShape_optional &FuzzyTermType::triangularShape() const { return this->triangularShape_; }

FuzzyTermType::triangularShape_optional &FuzzyTermType::triangularShape() { return this->triangularShape_; }

void FuzzyTermType::triangularShape(const triangularShape_type &x) { this->triangularShape_.set(x); }

void FuzzyTermType::triangularShape(const triangularShape_optional &x) { this->triangularShape_ = x; }

void FuzzyTermType::triangularShape(::std::unique_ptr<triangularShape_type> x) {
  this->triangularShape_.set(std::move(x));
}

const FuzzyTermType::gaussianShape_optional &FuzzyTermType::gaussianShape() const { return this->gaussianShape_; }

FuzzyTermType::gaussianShape_optional &FuzzyTermType::gaussianShape() { return this->gaussianShape_; }

void FuzzyTermType::gaussianShape(const gaussianShape_type &x) { this->gaussianShape_.set(x); }

void FuzzyTermType::gaussianShape(const gaussianShape_optional &x) { this->gaussianShape_ = x; }

void FuzzyTermType::gaussianShape(::std::unique_ptr<gaussianShape_type> x) { this->gaussianShape_.set(std::move(x)); }

const FuzzyTermType::rightGaussianShape_optional &FuzzyTermType::rightGaussianShape() const {
  return this->rightGaussianShape_;
}

FuzzyTermType::rightGaussianShape_optional &FuzzyTermType::rightGaussianShape() { return this->rightGaussianShape_; }

void FuzzyTermType::rightGaussianShape(const rightGaussianShape_type &x) { this->rightGaussianShape_.set(x); }

void FuzzyTermType::rightGaussianShape(const rightGaussianShape_optional &x) { this->rightGaussianShape_ = x; }

void FuzzyTermType::rightGaussianShape(::std::unique_ptr<rightGaussianShape_type> x) {
  this->rightGaussianShape_.set(std::move(x));
}

const FuzzyTermType::leftGaussianShape_optional &FuzzyTermType::leftGaussianShape() const {
  return this->leftGaussianShape_;
}

FuzzyTermType::leftGaussianShape_optional &FuzzyTermType::leftGaussianShape() { return this->leftGaussianShape_; }

void FuzzyTermType::leftGaussianShape(const leftGaussianShape_type &x) { this->leftGaussianShape_.set(x); }

void FuzzyTermType::leftGaussianShape(const leftGaussianShape_optional &x) { this->leftGaussianShape_ = x; }

void FuzzyTermType::leftGaussianShape(::std::unique_ptr<leftGaussianShape_type> x) {
  this->leftGaussianShape_.set(std::move(x));
}

const FuzzyTermType::trapezoidShape_optional &FuzzyTermType::trapezoidShape() const { return this->trapezoidShape_; }

FuzzyTermType::trapezoidShape_optional &FuzzyTermType::trapezoidShape() { return this->trapezoidShape_; }

void FuzzyTermType::trapezoidShape(const trapezoidShape_type &x) { this->trapezoidShape_.set(x); }

void FuzzyTermType::trapezoidShape(const trapezoidShape_optional &x) { this->trapezoidShape_ = x; }

void FuzzyTermType::trapezoidShape(::std::unique_ptr<trapezoidShape_type> x) {
  this->trapezoidShape_.set(std::move(x));
}

const FuzzyTermType::singletonShape_optional &FuzzyTermType::singletonShape() const { return this->singletonShape_; }

FuzzyTermType::singletonShape_optional &FuzzyTermType::singletonShape() { return this->singletonShape_; }

void FuzzyTermType::singletonShape(const singletonShape_type &x) { this->singletonShape_.set(x); }

void FuzzyTermType::singletonShape(const singletonShape_optional &x) { this->singletonShape_ = x; }

void FuzzyTermType::singletonShape(::std::unique_ptr<singletonShape_type> x) {
  this->singletonShape_.set(std::move(x));
}

const FuzzyTermType::rectangularShape_optional &FuzzyTermType::rectangularShape() const {
  return this->rectangularShape_;
}

FuzzyTermType::rectangularShape_optional &FuzzyTermType::rectangularShape() { return this->rectangularShape_; }

void FuzzyTermType::rectangularShape(const rectangularShape_type &x) { this->rectangularShape_.set(x); }

void FuzzyTermType::rectangularShape(const rectangularShape_optional &x) { this->rectangularShape_ = x; }

void FuzzyTermType::rectangularShape(::std::unique_ptr<rectangularShape_type> x) {
  this->rectangularShape_.set(std::move(x));
}

const FuzzyTermType::zShape_optional &FuzzyTermType::zShape() const { return this->zShape_; }

FuzzyTermType::zShape_optional &FuzzyTermType::zShape() { return this->zShape_; }

void FuzzyTermType::zShape(const zShape_type &x) { this->zShape_.set(x); }

void FuzzyTermType::zShape(const zShape_optional &x) { this->zShape_ = x; }

void FuzzyTermType::zShape(::std::unique_ptr<zShape_type> x) { this->zShape_.set(std::move(x)); }

const FuzzyTermType::sShape_optional &FuzzyTermType::sShape() const { return this->sShape_; }

FuzzyTermType::sShape_optional &FuzzyTermType::sShape() { return this->sShape_; }

void FuzzyTermType::sShape(const sShape_type &x) { this->sShape_.set(x); }

void FuzzyTermType::sShape(const sShape_optional &x) { this->sShape_ = x; }

void FuzzyTermType::sShape(::std::unique_ptr<sShape_type> x) { this->sShape_.set(std::move(x)); }

const FuzzyTermType::userShape_optional &FuzzyTermType::userShape() const { return this->userShape_; }

FuzzyTermType::userShape_optional &FuzzyTermType::userShape() { return this->userShape_; }

void FuzzyTermType::userShape(const userShape_type &x) { this->userShape_.set(x); }

void FuzzyTermType::userShape(const userShape_optional &x) { this->userShape_ = x; }

void FuzzyTermType::userShape(::std::unique_ptr<userShape_type> x) { this->userShape_.set(std::move(x)); }

const FuzzyTermType::name_type &FuzzyTermType::name() const { return this->name_.get(); }

FuzzyTermType::name_type &FuzzyTermType::name() { return this->name_.get(); }

void FuzzyTermType::name(const name_type &x) { this->name_.set(x); }

void FuzzyTermType::name(::std::unique_ptr<name_type> x) { this->name_.set(std::move(x)); }

const FuzzyTermType::complement_type &FuzzyTermType::complement() const { return this->complement_.get(); }

FuzzyTermType::complement_type &FuzzyTermType::complement() { return this->complement_.get(); }

void FuzzyTermType::complement(const complement_type &x) { this->complement_.set(x); }

void FuzzyTermType::complement(::std::unique_ptr<complement_type> x) { this->complement_.set(std::move(x)); }

FuzzyTermType::complement_type FuzzyTermType::complement_default_value() { return complement_type(false); }

// OneParamType
//

const OneParamType::param1_type &OneParamType::param1() const { return this->param1_.get(); }

OneParamType::param1_type &OneParamType::param1() { return this->param1_.get(); }

void OneParamType::param1(const param1_type &x) { this->param1_.set(x); }

// TwoParamType
//

const TwoParamType::param1_type &TwoParamType::param1() const { return this->param1_.get(); }

TwoParamType::param1_type &TwoParamType::param1() { return this->param1_.get(); }

void TwoParamType::param1(const param1_type &x) { this->param1_.set(x); }

const TwoParamType::param2_type &TwoParamType::param2() const { return this->param2_.get(); }

TwoParamType::param2_type &TwoParamType::param2() { return this->param2_.get(); }

void TwoParamType::param2(const param2_type &x) { this->param2_.set(x); }

// ThreeParamType
//

const ThreeParamType::param1_type &ThreeParamType::param1() const { return this->param1_.get(); }

ThreeParamType::param1_type &ThreeParamType::param1() { return this->param1_.get(); }

void ThreeParamType::param1(const param1_type &x) { this->param1_.set(x); }

const ThreeParamType::param2_type &ThreeParamType::param2() const { return this->param2_.get(); }

ThreeParamType::param2_type &ThreeParamType::param2() { return this->param2_.get(); }

void ThreeParamType::param2(const param2_type &x) { this->param2_.set(x); }

const ThreeParamType::param3_type &ThreeParamType::param3() const { return this->param3_.get(); }

ThreeParamType::param3_type &ThreeParamType::param3() { return this->param3_.get(); }

void ThreeParamType::param3(const param3_type &x) { this->param3_.set(x); }

// FourParamType
//

const FourParamType::param1_type &FourParamType::param1() const { return this->param1_.get(); }

FourParamType::param1_type &FourParamType::param1() { return this->param1_.get(); }

void FourParamType::param1(const param1_type &x) { this->param1_.set(x); }

const FourParamType::param2_type &FourParamType::param2() const { return this->param2_.get(); }

FourParamType::param2_type &FourParamType::param2() { return this->param2_.get(); }

void FourParamType::param2(const param2_type &x) { this->param2_.set(x); }

const FourParamType::param3_type &FourParamType::param3() const { return this->param3_.get(); }

FourParamType::param3_type &FourParamType::param3() { return this->param3_.get(); }

void FourParamType::param3(const param3_type &x) { this->param3_.set(x); }

const FourParamType::param4_type &FourParamType::param4() const { return this->param4_.get(); }

FourParamType::param4_type &FourParamType::param4() { return this->param4_.get(); }

void FourParamType::param4(const param4_type &x) { this->param4_.set(x); }

// UserShapeType
//

const UserShapeType::Point_sequence &UserShapeType::Point() const { return this->Point_; }

UserShapeType::Point_sequence &UserShapeType::Point() { return this->Point_; }

void UserShapeType::Point(const Point_sequence &s) { this->Point_ = s; }

// PointType
//

const PointType::x_type &PointType::x() const { return this->x_.get(); }

PointType::x_type &PointType::x() { return this->x_.get(); }

void PointType::x(const x_type &x) { this->x_.set(x); }

const PointType::y_type &PointType::y() const { return this->y_.get(); }

PointType::y_type &PointType::y() { return this->y_.get(); }

void PointType::y(const y_type &x) { this->y_.set(x); }

// RuleBaseType
//

const RuleBaseType::name_type &RuleBaseType::name() const { return this->name_.get(); }

RuleBaseType::name_type &RuleBaseType::name() { return this->name_.get(); }

void RuleBaseType::name(const name_type &x) { this->name_.set(x); }

void RuleBaseType::name(::std::unique_ptr<name_type> x) { this->name_.set(std::move(x)); }

const RuleBaseType::activationMethod_type &RuleBaseType::activationMethod() const {
  return this->activationMethod_.get();
}

RuleBaseType::activationMethod_type &RuleBaseType::activationMethod() { return this->activationMethod_.get(); }

void RuleBaseType::activationMethod(const activationMethod_type &x) { this->activationMethod_.set(x); }

void RuleBaseType::activationMethod(::std::unique_ptr<activationMethod_type> x) {
  this->activationMethod_.set(std::move(x));
}

const RuleBaseType::activationMethod_type &RuleBaseType::activationMethod_default_value() {
  return activationMethod_default_value_;
}

const RuleBaseType::andMethod_type &RuleBaseType::andMethod() const { return this->andMethod_.get(); }

RuleBaseType::andMethod_type &RuleBaseType::andMethod() { return this->andMethod_.get(); }

void RuleBaseType::andMethod(const andMethod_type &x) { this->andMethod_.set(x); }

void RuleBaseType::andMethod(::std::unique_ptr<andMethod_type> x) { this->andMethod_.set(std::move(x)); }

const RuleBaseType::andMethod_type &RuleBaseType::andMethod_default_value() { return andMethod_default_value_; }

const RuleBaseType::orMethod_type &RuleBaseType::orMethod() const { return this->orMethod_.get(); }

RuleBaseType::orMethod_type &RuleBaseType::orMethod() { return this->orMethod_.get(); }

void RuleBaseType::orMethod(const orMethod_type &x) { this->orMethod_.set(x); }

void RuleBaseType::orMethod(::std::unique_ptr<orMethod_type> x) { this->orMethod_.set(std::move(x)); }

const RuleBaseType::orMethod_type &RuleBaseType::orMethod_default_value() { return orMethod_default_value_; }

// MamdaniFuzzyRuleType
//

const MamdaniFuzzyRuleType::antecedent_type &MamdaniFuzzyRuleType::antecedent() const {
  return this->antecedent_.get();
}

MamdaniFuzzyRuleType::antecedent_type &MamdaniFuzzyRuleType::antecedent() { return this->antecedent_.get(); }

void MamdaniFuzzyRuleType::antecedent(const antecedent_type &x) { this->antecedent_.set(x); }

void MamdaniFuzzyRuleType::antecedent(::std::unique_ptr<antecedent_type> x) { this->antecedent_.set(std::move(x)); }

const MamdaniFuzzyRuleType::consequent_type &MamdaniFuzzyRuleType::consequent() const {
  return this->consequent_.get();
}

MamdaniFuzzyRuleType::consequent_type &MamdaniFuzzyRuleType::consequent() { return this->consequent_.get(); }

void MamdaniFuzzyRuleType::consequent(const consequent_type &x) { this->consequent_.set(x); }

void MamdaniFuzzyRuleType::consequent(::std::unique_ptr<consequent_type> x) { this->consequent_.set(std::move(x)); }

const MamdaniFuzzyRuleType::name_type &MamdaniFuzzyRuleType::name() const { return this->name_.get(); }

MamdaniFuzzyRuleType::name_type &MamdaniFuzzyRuleType::name() { return this->name_.get(); }

void MamdaniFuzzyRuleType::name(const name_type &x) { this->name_.set(x); }

void MamdaniFuzzyRuleType::name(::std::unique_ptr<name_type> x) { this->name_.set(std::move(x)); }

const MamdaniFuzzyRuleType::andMethod_type &MamdaniFuzzyRuleType::andMethod() const { return this->andMethod_.get(); }

MamdaniFuzzyRuleType::andMethod_type &MamdaniFuzzyRuleType::andMethod() { return this->andMethod_.get(); }

void MamdaniFuzzyRuleType::andMethod(const andMethod_type &x) { this->andMethod_.set(x); }

void MamdaniFuzzyRuleType::andMethod(::std::unique_ptr<andMethod_type> x) { this->andMethod_.set(std::move(x)); }

const MamdaniFuzzyRuleType::andMethod_type &MamdaniFuzzyRuleType::andMethod_default_value() {
  return andMethod_default_value_;
}

const MamdaniFuzzyRuleType::orMethod_type &MamdaniFuzzyRuleType::orMethod() const { return this->orMethod_.get(); }

MamdaniFuzzyRuleType::orMethod_type &MamdaniFuzzyRuleType::orMethod() { return this->orMethod_.get(); }

void MamdaniFuzzyRuleType::orMethod(const orMethod_type &x) { this->orMethod_.set(x); }

void MamdaniFuzzyRuleType::orMethod(::std::unique_ptr<orMethod_type> x) { this->orMethod_.set(std::move(x)); }

const MamdaniFuzzyRuleType::orMethod_type &MamdaniFuzzyRuleType::orMethod_default_value() {
  return orMethod_default_value_;
}

const MamdaniFuzzyRuleType::connector_type &MamdaniFuzzyRuleType::connector() const { return this->connector_.get(); }

MamdaniFuzzyRuleType::connector_type &MamdaniFuzzyRuleType::connector() { return this->connector_.get(); }

void MamdaniFuzzyRuleType::connector(const connector_type &x) { this->connector_.set(x); }

void MamdaniFuzzyRuleType::connector(::std::unique_ptr<connector_type> x) { this->connector_.set(std::move(x)); }

const MamdaniFuzzyRuleType::connector_type &MamdaniFuzzyRuleType::connector_default_value() {
  return connector_default_value_;
}

const MamdaniFuzzyRuleType::weight_type &MamdaniFuzzyRuleType::weight() const { return this->weight_.get(); }

MamdaniFuzzyRuleType::weight_type &MamdaniFuzzyRuleType::weight() { return this->weight_.get(); }

void MamdaniFuzzyRuleType::weight(const weight_type &x) { this->weight_.set(x); }

void MamdaniFuzzyRuleType::weight(::std::unique_ptr<weight_type> x) { this->weight_.set(std::move(x)); }

MamdaniFuzzyRuleType::weight_type MamdaniFuzzyRuleType::weight_default_value() { return weight_type(1.0F); }

// standardTnormType
//

standardTnormType::standardTnormType(value v) : ::xml_schema::string(_xsd_standardTnormType_literals_[v]) {}

standardTnormType::standardTnormType(const char *v) : ::xml_schema::string(v) {}

standardTnormType::standardTnormType(const ::std::string &v) : ::xml_schema::string(v) {}

standardTnormType::standardTnormType(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

standardTnormType::standardTnormType(const standardTnormType &v, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(v, f, c) {}

standardTnormType &standardTnormType::operator=(value v) {
  static_cast< ::xml_schema::string &>(*this) = ::xml_schema::string(_xsd_standardTnormType_literals_[v]);

  return *this;
}

// andMethodType
//

andMethodType::andMethodType(value v) : ::standardTnormType(v) {}

andMethodType::andMethodType(const char *v) : ::standardTnormType(v) {}

andMethodType::andMethodType(const ::std::string &v) : ::standardTnormType(v) {}

andMethodType::andMethodType(const ::standardTnormType &v) : ::standardTnormType(v) {}

andMethodType::andMethodType(const andMethodType &v, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::standardTnormType(v, f, c) {}

andMethodType &andMethodType::operator=(value v) {
  static_cast< ::standardTnormType &>(*this) = v;

  return *this;
}

// standardTconormType
//

standardTconormType::standardTconormType(value v) : ::xml_schema::string(_xsd_standardTconormType_literals_[v]) {}

standardTconormType::standardTconormType(const char *v) : ::xml_schema::string(v) {}

standardTconormType::standardTconormType(const ::std::string &v) : ::xml_schema::string(v) {}

standardTconormType::standardTconormType(const ::xml_schema::string &v) : ::xml_schema::string(v) {}

standardTconormType::standardTconormType(const standardTconormType &v, ::xml_schema::flags f,
                                         ::xml_schema::container *c)
    : ::xml_schema::string(v, f, c) {}

standardTconormType &standardTconormType::operator=(value v) {
  static_cast< ::xml_schema::string &>(*this) = ::xml_schema::string(_xsd_standardTconormType_literals_[v]);

  return *this;
}

// orMethodType
//

orMethodType::orMethodType(value v) : ::standardTconormType(v) {}

orMethodType::orMethodType(const char *v) : ::standardTconormType(v) {}

orMethodType::orMethodType(const ::std::string &v) : ::standardTconormType(v) {}

orMethodType::orMethodType(const ::standardTconormType &v) : ::standardTconormType(v) {}

orMethodType::orMethodType(const orMethodType &v, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::standardTconormType(v, f, c) {}

orMethodType &orMethodType::operator=(value v) {
  static_cast< ::standardTconormType &>(*this) = v;

  return *this;
}

// connectorType
//

// weightType
//

// MamdaniRuleBaseType
//

const MamdaniRuleBaseType::rule_sequence &MamdaniRuleBaseType::rule() const { return this->rule_; }

MamdaniRuleBaseType::rule_sequence &MamdaniRuleBaseType::rule() { return this->rule_; }

void MamdaniRuleBaseType::rule(const rule_sequence &s) { this->rule_ = s; }

// AntecedentType
//

const AntecedentType::clause_sequence &AntecedentType::clause() const { return this->clause_; }

AntecedentType::clause_sequence &AntecedentType::clause() { return this->clause_; }

void AntecedentType::clause(const clause_sequence &s) { this->clause_ = s; }

// MamdaniConsequentType
//

const MamdaniConsequentType::then_type &MamdaniConsequentType::then() const { return this->then_.get(); }

MamdaniConsequentType::then_type &MamdaniConsequentType::then() { return this->then_.get(); }

void MamdaniConsequentType::then(const then_type &x) { this->then_.set(x); }

void MamdaniConsequentType::then(::std::unique_ptr<then_type> x) { this->then_.set(std::move(x)); }

// ThenType
//

const ThenType::clause_sequence &ThenType::clause() const { return this->clause_; }

ThenType::clause_sequence &ThenType::clause() { return this->clause_; }

void ThenType::clause(const clause_sequence &s) { this->clause_ = s; }

// ClauseType
//

const ClauseType::variable_type &ClauseType::variable() const { return this->variable_.get(); }

ClauseType::variable_type &ClauseType::variable() { return this->variable_.get(); }

void ClauseType::variable(const variable_type &x) { this->variable_.set(x); }

void ClauseType::variable(::std::unique_ptr<variable_type> x) { this->variable_.set(std::move(x)); }

const ClauseType::term_type &ClauseType::term() const { return this->term_.get(); }

ClauseType::term_type &ClauseType::term() { return this->term_.get(); }

void ClauseType::term(const term_type &x) { this->term_.set(x); }

void ClauseType::term(::std::unique_ptr<term_type> x) { this->term_.set(std::move(x)); }

const ClauseType::modifier_optional &ClauseType::modifier() const { return this->modifier_; }

ClauseType::modifier_optional &ClauseType::modifier() { return this->modifier_; }

void ClauseType::modifier(const modifier_type &x) { this->modifier_.set(x); }

void ClauseType::modifier(const modifier_optional &x) { this->modifier_ = x; }

void ClauseType::modifier(::std::unique_ptr<modifier_type> x) { this->modifier_.set(std::move(x)); }

// defuzzifier
//

// accumulation
//

// type
//

// complement
//

// activationMethod
//

// andMethod
//

// orMethod
//

// variable
//

// modifier
//

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// FuzzySystemType
//

FuzzySystemType::FuzzySystemType(const knowledgeBase_type &knowledgeBase, const name_type &name)
    : ::xml_schema::type(), knowledgeBase_(knowledgeBase, this), mamdaniRuleBase_(this), name_(name, this) {}

FuzzySystemType::FuzzySystemType(::std::unique_ptr<knowledgeBase_type> knowledgeBase, const name_type &name)
    : ::xml_schema::type(), knowledgeBase_(std::move(knowledgeBase), this), mamdaniRuleBase_(this), name_(name, this) {}

FuzzySystemType::FuzzySystemType(const FuzzySystemType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      knowledgeBase_(x.knowledgeBase_, f, this),
      mamdaniRuleBase_(x.mamdaniRuleBase_, f, this),
      name_(x.name_, f, this) {}

FuzzySystemType::FuzzySystemType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      knowledgeBase_(this),
      mamdaniRuleBase_(this),
      name_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void FuzzySystemType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // knowledgeBase
    //
    if (n.name() == "knowledgeBase" && n.namespace_().empty()) {
      ::std::unique_ptr<knowledgeBase_type> r(knowledgeBase_traits::create(i, f, this));

      if (!knowledgeBase_.present()) {
        this->knowledgeBase_.set(::std::move(r));
        continue;
      }
    }

    // mamdaniRuleBase
    //
    if (n.name() == "mamdaniRuleBase" && n.namespace_().empty()) {
      ::std::unique_ptr<mamdaniRuleBase_type> r(mamdaniRuleBase_traits::create(i, f, this));

      this->mamdaniRuleBase_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  if (!knowledgeBase_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("knowledgeBase", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }
  }

  if (!name_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("name", "");
  }
}

FuzzySystemType *FuzzySystemType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class FuzzySystemType(*this, f, c);
}

FuzzySystemType &FuzzySystemType::operator=(const FuzzySystemType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->knowledgeBase_ = x.knowledgeBase_;
    this->mamdaniRuleBase_ = x.mamdaniRuleBase_;
    this->name_ = x.name_;
  }

  return *this;
}

FuzzySystemType::~FuzzySystemType() {}

// KnowledgeBaseType
//

KnowledgeBaseType::KnowledgeBaseType() : ::xml_schema::type(), fuzzyVariable_(this) {}

KnowledgeBaseType::KnowledgeBaseType(const KnowledgeBaseType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), fuzzyVariable_(x.fuzzyVariable_, f, this) {}

KnowledgeBaseType::KnowledgeBaseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), fuzzyVariable_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void KnowledgeBaseType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // fuzzyVariable
    //
    if (n.name() == "fuzzyVariable" && n.namespace_().empty()) {
      ::std::unique_ptr<fuzzyVariable_type> r(fuzzyVariable_traits::create(i, f, this));

      this->fuzzyVariable_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

KnowledgeBaseType *KnowledgeBaseType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class KnowledgeBaseType(*this, f, c);
}

KnowledgeBaseType &KnowledgeBaseType::operator=(const KnowledgeBaseType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->fuzzyVariable_ = x.fuzzyVariable_;
  }

  return *this;
}

KnowledgeBaseType::~KnowledgeBaseType() {}

// FuzzyVariableType
//

const FuzzyVariableType::defuzzifier_type FuzzyVariableType::defuzzifier_default_value_("COG");

const FuzzyVariableType::accumulation_type FuzzyVariableType::accumulation_default_value_("MAX");

const FuzzyVariableType::type_type FuzzyVariableType::type_default_value_("input");

FuzzyVariableType::FuzzyVariableType(const name_type &name, const domainleft_type &domainleft,
                                     const domainright_type &domainright)
    : ::xml_schema::type(),
      fuzzyTerm_(this),
      name_(name, this),
      defuzzifier_(defuzzifier_default_value(), this),
      accumulation_(accumulation_default_value(), this),
      scale_(this),
      domainleft_(domainleft, this),
      domainright_(domainright, this),
      defaultValue_(defaultValue_default_value(), this),
      type_(type_default_value(), this) {}

FuzzyVariableType::FuzzyVariableType(const FuzzyVariableType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      fuzzyTerm_(x.fuzzyTerm_, f, this),
      name_(x.name_, f, this),
      defuzzifier_(x.defuzzifier_, f, this),
      accumulation_(x.accumulation_, f, this),
      scale_(x.scale_, f, this),
      domainleft_(x.domainleft_, f, this),
      domainright_(x.domainright_, f, this),
      defaultValue_(x.defaultValue_, f, this),
      type_(x.type_, f, this) {}

FuzzyVariableType::FuzzyVariableType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      fuzzyTerm_(this),
      name_(this),
      defuzzifier_(this),
      accumulation_(this),
      scale_(this),
      domainleft_(this),
      domainright_(this),
      defaultValue_(this),
      type_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void FuzzyVariableType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // fuzzyTerm
    //
    if (n.name() == "fuzzyTerm" && n.namespace_().empty()) {
      ::std::unique_ptr<fuzzyTerm_type> r(fuzzyTerm_traits::create(i, f, this));

      this->fuzzyTerm_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "defuzzifier" && n.namespace_().empty()) {
      this->defuzzifier_.set(defuzzifier_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "accumulation" && n.namespace_().empty()) {
      this->accumulation_.set(accumulation_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "scale" && n.namespace_().empty()) {
      this->scale_.set(scale_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "domainleft" && n.namespace_().empty()) {
      this->domainleft_.set(domainleft_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "domainright" && n.namespace_().empty()) {
      this->domainright_.set(domainright_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "defaultValue" && n.namespace_().empty()) {
      this->defaultValue_.set(defaultValue_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "type" && n.namespace_().empty()) {
      this->type_.set(type_traits::create(i, f, this));
      continue;
    }
  }

  if (!name_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("name", "");
  }

  if (!defuzzifier_.present()) {
    this->defuzzifier_.set(defuzzifier_default_value());
  }

  if (!accumulation_.present()) {
    this->accumulation_.set(accumulation_default_value());
  }

  if (!domainleft_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("domainleft", "");
  }

  if (!domainright_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("domainright", "");
  }

  if (!defaultValue_.present()) {
    this->defaultValue_.set(defaultValue_default_value());
  }

  if (!type_.present()) {
    this->type_.set(type_default_value());
  }
}

FuzzyVariableType *FuzzyVariableType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class FuzzyVariableType(*this, f, c);
}

FuzzyVariableType &FuzzyVariableType::operator=(const FuzzyVariableType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->fuzzyTerm_ = x.fuzzyTerm_;
    this->name_ = x.name_;
    this->defuzzifier_ = x.defuzzifier_;
    this->accumulation_ = x.accumulation_;
    this->scale_ = x.scale_;
    this->domainleft_ = x.domainleft_;
    this->domainright_ = x.domainright_;
    this->defaultValue_ = x.defaultValue_;
    this->type_ = x.type_;
  }

  return *this;
}

FuzzyVariableType::~FuzzyVariableType() {}

// FuzzyTermType
//

FuzzyTermType::FuzzyTermType(const name_type &name)
    : ::xml_schema::type(),
      rightLinearShape_(this),
      leftLinearShape_(this),
      piShape_(this),
      triangularShape_(this),
      gaussianShape_(this),
      rightGaussianShape_(this),
      leftGaussianShape_(this),
      trapezoidShape_(this),
      singletonShape_(this),
      rectangularShape_(this),
      zShape_(this),
      sShape_(this),
      userShape_(this),
      name_(name, this),
      complement_(complement_default_value(), this) {}

FuzzyTermType::FuzzyTermType(const FuzzyTermType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      rightLinearShape_(x.rightLinearShape_, f, this),
      leftLinearShape_(x.leftLinearShape_, f, this),
      piShape_(x.piShape_, f, this),
      triangularShape_(x.triangularShape_, f, this),
      gaussianShape_(x.gaussianShape_, f, this),
      rightGaussianShape_(x.rightGaussianShape_, f, this),
      leftGaussianShape_(x.leftGaussianShape_, f, this),
      trapezoidShape_(x.trapezoidShape_, f, this),
      singletonShape_(x.singletonShape_, f, this),
      rectangularShape_(x.rectangularShape_, f, this),
      zShape_(x.zShape_, f, this),
      sShape_(x.sShape_, f, this),
      userShape_(x.userShape_, f, this),
      name_(x.name_, f, this),
      complement_(x.complement_, f, this) {}

FuzzyTermType::FuzzyTermType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      rightLinearShape_(this),
      leftLinearShape_(this),
      piShape_(this),
      triangularShape_(this),
      gaussianShape_(this),
      rightGaussianShape_(this),
      leftGaussianShape_(this),
      trapezoidShape_(this),
      singletonShape_(this),
      rectangularShape_(this),
      zShape_(this),
      sShape_(this),
      userShape_(this),
      name_(this),
      complement_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void FuzzyTermType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // rightLinearShape
    //
    if (n.name() == "rightLinearShape" && n.namespace_().empty()) {
      ::std::unique_ptr<rightLinearShape_type> r(rightLinearShape_traits::create(i, f, this));

      if (!this->rightLinearShape_) {
        this->rightLinearShape_.set(::std::move(r));
        continue;
      }
    }

    // leftLinearShape
    //
    if (n.name() == "leftLinearShape" && n.namespace_().empty()) {
      ::std::unique_ptr<leftLinearShape_type> r(leftLinearShape_traits::create(i, f, this));

      if (!this->leftLinearShape_) {
        this->leftLinearShape_.set(::std::move(r));
        continue;
      }
    }

    // piShape
    //
    if (n.name() == "piShape" && n.namespace_().empty()) {
      ::std::unique_ptr<piShape_type> r(piShape_traits::create(i, f, this));

      if (!this->piShape_) {
        this->piShape_.set(::std::move(r));
        continue;
      }
    }

    // triangularShape
    //
    if (n.name() == "triangularShape" && n.namespace_().empty()) {
      ::std::unique_ptr<triangularShape_type> r(triangularShape_traits::create(i, f, this));

      if (!this->triangularShape_) {
        this->triangularShape_.set(::std::move(r));
        continue;
      }
    }

    // gaussianShape
    //
    if (n.name() == "gaussianShape" && n.namespace_().empty()) {
      ::std::unique_ptr<gaussianShape_type> r(gaussianShape_traits::create(i, f, this));

      if (!this->gaussianShape_) {
        this->gaussianShape_.set(::std::move(r));
        continue;
      }
    }

    // rightGaussianShape
    //
    if (n.name() == "rightGaussianShape" && n.namespace_().empty()) {
      ::std::unique_ptr<rightGaussianShape_type> r(rightGaussianShape_traits::create(i, f, this));

      if (!this->rightGaussianShape_) {
        this->rightGaussianShape_.set(::std::move(r));
        continue;
      }
    }

    // leftGaussianShape
    //
    if (n.name() == "leftGaussianShape" && n.namespace_().empty()) {
      ::std::unique_ptr<leftGaussianShape_type> r(leftGaussianShape_traits::create(i, f, this));

      if (!this->leftGaussianShape_) {
        this->leftGaussianShape_.set(::std::move(r));
        continue;
      }
    }

    // trapezoidShape
    //
    if (n.name() == "trapezoidShape" && n.namespace_().empty()) {
      ::std::unique_ptr<trapezoidShape_type> r(trapezoidShape_traits::create(i, f, this));

      if (!this->trapezoidShape_) {
        this->trapezoidShape_.set(::std::move(r));
        continue;
      }
    }

    // singletonShape
    //
    if (n.name() == "singletonShape" && n.namespace_().empty()) {
      ::std::unique_ptr<singletonShape_type> r(singletonShape_traits::create(i, f, this));

      if (!this->singletonShape_) {
        this->singletonShape_.set(::std::move(r));
        continue;
      }
    }

    // rectangularShape
    //
    if (n.name() == "rectangularShape" && n.namespace_().empty()) {
      ::std::unique_ptr<rectangularShape_type> r(rectangularShape_traits::create(i, f, this));

      if (!this->rectangularShape_) {
        this->rectangularShape_.set(::std::move(r));
        continue;
      }
    }

    // zShape
    //
    if (n.name() == "zShape" && n.namespace_().empty()) {
      ::std::unique_ptr<zShape_type> r(zShape_traits::create(i, f, this));

      if (!this->zShape_) {
        this->zShape_.set(::std::move(r));
        continue;
      }
    }

    // sShape
    //
    if (n.name() == "sShape" && n.namespace_().empty()) {
      ::std::unique_ptr<sShape_type> r(sShape_traits::create(i, f, this));

      if (!this->sShape_) {
        this->sShape_.set(::std::move(r));
        continue;
      }
    }

    // userShape
    //
    if (n.name() == "userShape" && n.namespace_().empty()) {
      ::std::unique_ptr<userShape_type> r(userShape_traits::create(i, f, this));

      if (!this->userShape_) {
        this->userShape_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "complement" && n.namespace_().empty()) {
      this->complement_.set(complement_traits::create(i, f, this));
      continue;
    }
  }

  if (!name_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("name", "");
  }

  if (!complement_.present()) {
    this->complement_.set(complement_default_value());
  }
}

FuzzyTermType *FuzzyTermType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class FuzzyTermType(*this, f, c);
}

FuzzyTermType &FuzzyTermType::operator=(const FuzzyTermType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->rightLinearShape_ = x.rightLinearShape_;
    this->leftLinearShape_ = x.leftLinearShape_;
    this->piShape_ = x.piShape_;
    this->triangularShape_ = x.triangularShape_;
    this->gaussianShape_ = x.gaussianShape_;
    this->rightGaussianShape_ = x.rightGaussianShape_;
    this->leftGaussianShape_ = x.leftGaussianShape_;
    this->trapezoidShape_ = x.trapezoidShape_;
    this->singletonShape_ = x.singletonShape_;
    this->rectangularShape_ = x.rectangularShape_;
    this->zShape_ = x.zShape_;
    this->sShape_ = x.sShape_;
    this->userShape_ = x.userShape_;
    this->name_ = x.name_;
    this->complement_ = x.complement_;
  }

  return *this;
}

FuzzyTermType::~FuzzyTermType() {}

// OneParamType
//

OneParamType::OneParamType(const param1_type &param1) : ::xml_schema::type(), param1_(param1, this) {}

OneParamType::OneParamType(const OneParamType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), param1_(x.param1_, f, this) {}

OneParamType::OneParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), param1_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void OneParamType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "param1" && n.namespace_().empty()) {
      this->param1_.set(param1_traits::create(i, f, this));
      continue;
    }
  }

  if (!param1_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param1", "");
  }
}

OneParamType *OneParamType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class OneParamType(*this, f, c);
}

OneParamType &OneParamType::operator=(const OneParamType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->param1_ = x.param1_;
  }

  return *this;
}

OneParamType::~OneParamType() {}

// TwoParamType
//

TwoParamType::TwoParamType(const param1_type &param1, const param2_type &param2)
    : ::xml_schema::type(), param1_(param1, this), param2_(param2, this) {}

TwoParamType::TwoParamType(const TwoParamType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), param1_(x.param1_, f, this), param2_(x.param2_, f, this) {}

TwoParamType::TwoParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), param1_(this), param2_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void TwoParamType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "param1" && n.namespace_().empty()) {
      this->param1_.set(param1_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "param2" && n.namespace_().empty()) {
      this->param2_.set(param2_traits::create(i, f, this));
      continue;
    }
  }

  if (!param1_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param1", "");
  }

  if (!param2_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param2", "");
  }
}

TwoParamType *TwoParamType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class TwoParamType(*this, f, c);
}

TwoParamType &TwoParamType::operator=(const TwoParamType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->param1_ = x.param1_;
    this->param2_ = x.param2_;
  }

  return *this;
}

TwoParamType::~TwoParamType() {}

// ThreeParamType
//

ThreeParamType::ThreeParamType(const param1_type &param1, const param2_type &param2, const param3_type &param3)
    : ::xml_schema::type(), param1_(param1, this), param2_(param2, this), param3_(param3, this) {}

ThreeParamType::ThreeParamType(const ThreeParamType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      param1_(x.param1_, f, this),
      param2_(x.param2_, f, this),
      param3_(x.param3_, f, this) {}

ThreeParamType::ThreeParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), param1_(this), param2_(this), param3_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void ThreeParamType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "param1" && n.namespace_().empty()) {
      this->param1_.set(param1_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "param2" && n.namespace_().empty()) {
      this->param2_.set(param2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "param3" && n.namespace_().empty()) {
      this->param3_.set(param3_traits::create(i, f, this));
      continue;
    }
  }

  if (!param1_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param1", "");
  }

  if (!param2_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param2", "");
  }

  if (!param3_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param3", "");
  }
}

ThreeParamType *ThreeParamType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class ThreeParamType(*this, f, c);
}

ThreeParamType &ThreeParamType::operator=(const ThreeParamType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->param1_ = x.param1_;
    this->param2_ = x.param2_;
    this->param3_ = x.param3_;
  }

  return *this;
}

ThreeParamType::~ThreeParamType() {}

// FourParamType
//

FourParamType::FourParamType(const param1_type &param1, const param2_type &param2, const param3_type &param3,
                             const param4_type &param4)
    : ::xml_schema::type(),
      param1_(param1, this),
      param2_(param2, this),
      param3_(param3, this),
      param4_(param4, this) {}

FourParamType::FourParamType(const FourParamType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      param1_(x.param1_, f, this),
      param2_(x.param2_, f, this),
      param3_(x.param3_, f, this),
      param4_(x.param4_, f, this) {}

FourParamType::FourParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      param1_(this),
      param2_(this),
      param3_(this),
      param4_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void FourParamType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "param1" && n.namespace_().empty()) {
      this->param1_.set(param1_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "param2" && n.namespace_().empty()) {
      this->param2_.set(param2_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "param3" && n.namespace_().empty()) {
      this->param3_.set(param3_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "param4" && n.namespace_().empty()) {
      this->param4_.set(param4_traits::create(i, f, this));
      continue;
    }
  }

  if (!param1_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param1", "");
  }

  if (!param2_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param2", "");
  }

  if (!param3_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param3", "");
  }

  if (!param4_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("param4", "");
  }
}

FourParamType *FourParamType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class FourParamType(*this, f, c);
}

FourParamType &FourParamType::operator=(const FourParamType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->param1_ = x.param1_;
    this->param2_ = x.param2_;
    this->param3_ = x.param3_;
    this->param4_ = x.param4_;
  }

  return *this;
}

FourParamType::~FourParamType() {}

// UserShapeType
//

UserShapeType::UserShapeType() : ::xml_schema::type(), Point_(this) {}

UserShapeType::UserShapeType(const UserShapeType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), Point_(x.Point_, f, this) {}

UserShapeType::UserShapeType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), Point_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void UserShapeType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // Point
    //
    if (n.name() == "Point" && n.namespace_().empty()) {
      ::std::unique_ptr<Point_type> r(Point_traits::create(i, f, this));

      this->Point_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

UserShapeType *UserShapeType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class UserShapeType(*this, f, c);
}

UserShapeType &UserShapeType::operator=(const UserShapeType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->Point_ = x.Point_;
  }

  return *this;
}

UserShapeType::~UserShapeType() {}

// PointType
//

PointType::PointType(const x_type &x, const y_type &y) : ::xml_schema::type(), x_(x, this), y_(y, this) {}

PointType::PointType(const PointType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), x_(x.x_, f, this), y_(x.y_, f, this) {}

PointType::PointType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), x_(this), y_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void PointType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "x" && n.namespace_().empty()) {
      this->x_.set(x_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "y" && n.namespace_().empty()) {
      this->y_.set(y_traits::create(i, f, this));
      continue;
    }
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("y", "");
  }
}

PointType *PointType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class PointType(*this, f, c);
}

PointType &PointType::operator=(const PointType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
  }

  return *this;
}

PointType::~PointType() {}

// RuleBaseType
//

const RuleBaseType::activationMethod_type RuleBaseType::activationMethod_default_value_("MIN");

const RuleBaseType::andMethod_type RuleBaseType::andMethod_default_value_("MIN");

const RuleBaseType::orMethod_type RuleBaseType::orMethod_default_value_("MAX");

RuleBaseType::RuleBaseType(const name_type &name)
    : ::xml_schema::type(),
      name_(name, this),
      activationMethod_(activationMethod_default_value(), this),
      andMethod_(andMethod_default_value(), this),
      orMethod_(orMethod_default_value(), this) {}

RuleBaseType::RuleBaseType(const RuleBaseType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      name_(x.name_, f, this),
      activationMethod_(x.activationMethod_, f, this),
      andMethod_(x.andMethod_, f, this),
      orMethod_(x.orMethod_, f, this) {}

RuleBaseType::RuleBaseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      name_(this),
      activationMethod_(this),
      andMethod_(this),
      orMethod_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void RuleBaseType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "activationMethod" && n.namespace_().empty()) {
      this->activationMethod_.set(activationMethod_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "andMethod" && n.namespace_().empty()) {
      this->andMethod_.set(andMethod_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "orMethod" && n.namespace_().empty()) {
      this->orMethod_.set(orMethod_traits::create(i, f, this));
      continue;
    }
  }

  if (!name_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("name", "");
  }

  if (!activationMethod_.present()) {
    this->activationMethod_.set(activationMethod_default_value());
  }

  if (!andMethod_.present()) {
    this->andMethod_.set(andMethod_default_value());
  }

  if (!orMethod_.present()) {
    this->orMethod_.set(orMethod_default_value());
  }
}

RuleBaseType *RuleBaseType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class RuleBaseType(*this, f, c);
}

RuleBaseType &RuleBaseType::operator=(const RuleBaseType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->name_ = x.name_;
    this->activationMethod_ = x.activationMethod_;
    this->andMethod_ = x.andMethod_;
    this->orMethod_ = x.orMethod_;
  }

  return *this;
}

RuleBaseType::~RuleBaseType() {}

// MamdaniFuzzyRuleType
//

const MamdaniFuzzyRuleType::andMethod_type MamdaniFuzzyRuleType::andMethod_default_value_("MIN");

const MamdaniFuzzyRuleType::orMethod_type MamdaniFuzzyRuleType::orMethod_default_value_("MAX");

const MamdaniFuzzyRuleType::connector_type MamdaniFuzzyRuleType::connector_default_value_("and");

MamdaniFuzzyRuleType::MamdaniFuzzyRuleType(const antecedent_type &antecedent, const consequent_type &consequent,
                                           const name_type &name)
    : ::xml_schema::type(),
      antecedent_(antecedent, this),
      consequent_(consequent, this),
      name_(name, this),
      andMethod_(andMethod_default_value(), this),
      orMethod_(orMethod_default_value(), this),
      connector_(connector_default_value(), this),
      weight_(weight_default_value(), this) {}

MamdaniFuzzyRuleType::MamdaniFuzzyRuleType(::std::unique_ptr<antecedent_type> antecedent,
                                           ::std::unique_ptr<consequent_type> consequent, const name_type &name)
    : ::xml_schema::type(),
      antecedent_(std::move(antecedent), this),
      consequent_(std::move(consequent), this),
      name_(name, this),
      andMethod_(andMethod_default_value(), this),
      orMethod_(orMethod_default_value(), this),
      connector_(connector_default_value(), this),
      weight_(weight_default_value(), this) {}

MamdaniFuzzyRuleType::MamdaniFuzzyRuleType(const MamdaniFuzzyRuleType &x, ::xml_schema::flags f,
                                           ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      antecedent_(x.antecedent_, f, this),
      consequent_(x.consequent_, f, this),
      name_(x.name_, f, this),
      andMethod_(x.andMethod_, f, this),
      orMethod_(x.orMethod_, f, this),
      connector_(x.connector_, f, this),
      weight_(x.weight_, f, this) {}

MamdaniFuzzyRuleType::MamdaniFuzzyRuleType(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                                           ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      antecedent_(this),
      consequent_(this),
      name_(this),
      andMethod_(this),
      orMethod_(this),
      connector_(this),
      weight_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void MamdaniFuzzyRuleType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // antecedent
    //
    if (n.name() == "antecedent" && n.namespace_().empty()) {
      ::std::unique_ptr<antecedent_type> r(antecedent_traits::create(i, f, this));

      if (!antecedent_.present()) {
        this->antecedent_.set(::std::move(r));
        continue;
      }
    }

    // consequent
    //
    if (n.name() == "consequent" && n.namespace_().empty()) {
      ::std::unique_ptr<consequent_type> r(consequent_traits::create(i, f, this));

      if (!consequent_.present()) {
        this->consequent_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!antecedent_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("antecedent", "");
  }

  if (!consequent_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("consequent", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(name_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "andMethod" && n.namespace_().empty()) {
      this->andMethod_.set(andMethod_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "orMethod" && n.namespace_().empty()) {
      this->orMethod_.set(orMethod_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "connector" && n.namespace_().empty()) {
      this->connector_.set(connector_traits::create(i, f, this));
      continue;
    }

    if (n.name() == "weight" && n.namespace_().empty()) {
      this->weight_.set(weight_traits::create(i, f, this));
      continue;
    }
  }

  if (!name_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("name", "");
  }

  if (!andMethod_.present()) {
    this->andMethod_.set(andMethod_default_value());
  }

  if (!orMethod_.present()) {
    this->orMethod_.set(orMethod_default_value());
  }

  if (!connector_.present()) {
    this->connector_.set(connector_default_value());
  }

  if (!weight_.present()) {
    this->weight_.set(weight_default_value());
  }
}

MamdaniFuzzyRuleType *MamdaniFuzzyRuleType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class MamdaniFuzzyRuleType(*this, f, c);
}

MamdaniFuzzyRuleType &MamdaniFuzzyRuleType::operator=(const MamdaniFuzzyRuleType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->antecedent_ = x.antecedent_;
    this->consequent_ = x.consequent_;
    this->name_ = x.name_;
    this->andMethod_ = x.andMethod_;
    this->orMethod_ = x.orMethod_;
    this->connector_ = x.connector_;
    this->weight_ = x.weight_;
  }

  return *this;
}

MamdaniFuzzyRuleType::~MamdaniFuzzyRuleType() {}

// standardTnormType
//

standardTnormType::standardTnormType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {
  _xsd_standardTnormType_convert();
}

standardTnormType::standardTnormType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {
  _xsd_standardTnormType_convert();
}

standardTnormType::standardTnormType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                                     ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {
  _xsd_standardTnormType_convert();
}

standardTnormType *standardTnormType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class standardTnormType(*this, f, c);
}

standardTnormType::value standardTnormType::_xsd_standardTnormType_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_standardTnormType_literals_);
  const value *i(::std::lower_bound(_xsd_standardTnormType_indexes_, _xsd_standardTnormType_indexes_ + 7, *this, c));

  if (i == _xsd_standardTnormType_indexes_ + 7 || _xsd_standardTnormType_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const standardTnormType::_xsd_standardTnormType_literals_[7] = {"MIN",   "PROD",  "BSUM",  "DRS",
                                                                            "EPROD", "HPROD", "NILMIN"};

const standardTnormType::value standardTnormType::_xsd_standardTnormType_indexes_[7] = {
    ::standardTnormType::BSUM, ::standardTnormType::DRS,    ::standardTnormType::EPROD, ::standardTnormType::HPROD,
    ::standardTnormType::MIN,  ::standardTnormType::NILMIN, ::standardTnormType::PROD};

// andMethodType
//

andMethodType::andMethodType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::standardTnormType(e, f, c) {
  _xsd_andMethodType_convert();
}

andMethodType::andMethodType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::standardTnormType(a, f, c) {
  _xsd_andMethodType_convert();
}

andMethodType::andMethodType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                             ::xml_schema::container *c)
    : ::standardTnormType(s, e, f, c) {
  _xsd_andMethodType_convert();
}

andMethodType *andMethodType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class andMethodType(*this, f, c);
}

andMethodType::value andMethodType::_xsd_andMethodType_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_andMethodType_literals_);
  const value *i(::std::lower_bound(_xsd_andMethodType_indexes_, _xsd_andMethodType_indexes_ + 7, *this, c));

  if (i == _xsd_andMethodType_indexes_ + 7 || _xsd_andMethodType_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const *andMethodType::_xsd_andMethodType_literals_ = ::standardTnormType::_xsd_standardTnormType_literals_;

const andMethodType::value andMethodType::_xsd_andMethodType_indexes_[7] = {
    ::andMethodType::BSUM, ::andMethodType::DRS,    ::andMethodType::EPROD, ::andMethodType::HPROD,
    ::andMethodType::MIN,  ::andMethodType::NILMIN, ::andMethodType::PROD};

// standardTconormType
//

standardTconormType::standardTconormType(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                                         ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {
  _xsd_standardTconormType_convert();
}

standardTconormType::standardTconormType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {
  _xsd_standardTconormType_convert();
}

standardTconormType::standardTconormType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                                         ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {
  _xsd_standardTconormType_convert();
}

standardTconormType *standardTconormType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class standardTconormType(*this, f, c);
}

standardTconormType::value standardTconormType::_xsd_standardTconormType_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_standardTconormType_literals_);
  const value *i(
      ::std::lower_bound(_xsd_standardTconormType_indexes_, _xsd_standardTconormType_indexes_ + 7, *this, c));

  if (i == _xsd_standardTconormType_indexes_ + 7 || _xsd_standardTconormType_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const standardTconormType::_xsd_standardTconormType_literals_[7] = {"MAX",  "PROBOR", "BSUM",  "DRS",
                                                                                "ESUM", "HSUM",   "NILMAX"};

const standardTconormType::value standardTconormType::_xsd_standardTconormType_indexes_[7] = {
    ::standardTconormType::BSUM,  ::standardTconormType::DRS, ::standardTconormType::ESUM,
    ::standardTconormType::HSUM,  ::standardTconormType::MAX, ::standardTconormType::NILMAX,
    ::standardTconormType::PROBOR};

// orMethodType
//

orMethodType::orMethodType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::standardTconormType(e, f, c) {
  _xsd_orMethodType_convert();
}

orMethodType::orMethodType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::standardTconormType(a, f, c) {
  _xsd_orMethodType_convert();
}

orMethodType::orMethodType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                           ::xml_schema::container *c)
    : ::standardTconormType(s, e, f, c) {
  _xsd_orMethodType_convert();
}

orMethodType *orMethodType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class orMethodType(*this, f, c);
}

orMethodType::value orMethodType::_xsd_orMethodType_convert() const {
  ::xsd::cxx::tree::enum_comparator<char> c(_xsd_orMethodType_literals_);
  const value *i(::std::lower_bound(_xsd_orMethodType_indexes_, _xsd_orMethodType_indexes_ + 7, *this, c));

  if (i == _xsd_orMethodType_indexes_ + 7 || _xsd_orMethodType_literals_[*i] != *this) {
    throw ::xsd::cxx::tree::unexpected_enumerator<char>(*this);
  }

  return *i;
}

const char *const *orMethodType::_xsd_orMethodType_literals_ =
    ::standardTconormType::_xsd_standardTconormType_literals_;

const orMethodType::value orMethodType::_xsd_orMethodType_indexes_[7] = {
    ::orMethodType::BSUM, ::orMethodType::DRS,    ::orMethodType::ESUM,  ::orMethodType::HSUM,
    ::orMethodType::MAX,  ::orMethodType::NILMAX, ::orMethodType::PROBOR};

// connectorType
//

connectorType::connectorType() : ::xml_schema::string() {}

connectorType::connectorType(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

connectorType::connectorType(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

connectorType::connectorType(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

connectorType::connectorType(const connectorType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

connectorType::connectorType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

connectorType::connectorType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

connectorType::connectorType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                             ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

connectorType *connectorType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class connectorType(*this, f, c);
}

connectorType::~connectorType() {}

// weightType
//

weightType::weightType(const ::xml_schema::float_ &_xsd_float__base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type>(_xsd_float__base) {}

weightType::weightType(const weightType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type>(x, f, c) {}

weightType::weightType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type>(e, f, c) {}

weightType::weightType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type>(a, f, c) {}

weightType::weightType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type>(s, e, f, c) {}

weightType *weightType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class weightType(*this, f, c);
}

weightType::~weightType() {}

// MamdaniRuleBaseType
//

MamdaniRuleBaseType::MamdaniRuleBaseType(const name_type &name) : ::RuleBaseType(name), rule_(this) {}

MamdaniRuleBaseType::MamdaniRuleBaseType(const MamdaniRuleBaseType &x, ::xml_schema::flags f,
                                         ::xml_schema::container *c)
    : ::RuleBaseType(x, f, c), rule_(x.rule_, f, this) {}

MamdaniRuleBaseType::MamdaniRuleBaseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                                         ::xml_schema::container *c)
    : ::RuleBaseType(e, f | ::xml_schema::flags::base, c), rule_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void MamdaniRuleBaseType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  this->::RuleBaseType::parse(p, f);

  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // rule
    //
    if (n.name() == "rule" && n.namespace_().empty()) {
      ::std::unique_ptr<rule_type> r(rule_traits::create(i, f, this));

      this->rule_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

MamdaniRuleBaseType *MamdaniRuleBaseType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class MamdaniRuleBaseType(*this, f, c);
}

MamdaniRuleBaseType &MamdaniRuleBaseType::operator=(const MamdaniRuleBaseType &x) {
  if (this != &x) {
    static_cast< ::RuleBaseType &>(*this) = x;
    this->rule_ = x.rule_;
  }

  return *this;
}

MamdaniRuleBaseType::~MamdaniRuleBaseType() {}

// AntecedentType
//

AntecedentType::AntecedentType() : ::xml_schema::type(), clause_(this) {}

AntecedentType::AntecedentType(const AntecedentType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), clause_(x.clause_, f, this) {}

AntecedentType::AntecedentType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), clause_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void AntecedentType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // clause
    //
    if (n.name() == "clause" && n.namespace_().empty()) {
      ::std::unique_ptr<clause_type> r(clause_traits::create(i, f, this));

      this->clause_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

AntecedentType *AntecedentType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class AntecedentType(*this, f, c);
}

AntecedentType &AntecedentType::operator=(const AntecedentType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->clause_ = x.clause_;
  }

  return *this;
}

AntecedentType::~AntecedentType() {}

// MamdaniConsequentType
//

MamdaniConsequentType::MamdaniConsequentType(const then_type &then) : ::xml_schema::type(), then_(then, this) {}

MamdaniConsequentType::MamdaniConsequentType(::std::unique_ptr<then_type> then)
    : ::xml_schema::type(), then_(std::move(then), this) {}

MamdaniConsequentType::MamdaniConsequentType(const MamdaniConsequentType &x, ::xml_schema::flags f,
                                             ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), then_(x.then_, f, this) {}

MamdaniConsequentType::MamdaniConsequentType(const ::xercesc::DOMElement &e, ::xml_schema::flags f,
                                             ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), then_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void MamdaniConsequentType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // then
    //
    if (n.name() == "then" && n.namespace_().empty()) {
      ::std::unique_ptr<then_type> r(then_traits::create(i, f, this));

      if (!then_.present()) {
        this->then_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!then_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("then", "");
  }
}

MamdaniConsequentType *MamdaniConsequentType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class MamdaniConsequentType(*this, f, c);
}

MamdaniConsequentType &MamdaniConsequentType::operator=(const MamdaniConsequentType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->then_ = x.then_;
  }

  return *this;
}

MamdaniConsequentType::~MamdaniConsequentType() {}

// ThenType
//

ThenType::ThenType() : ::xml_schema::type(), clause_(this) {}

ThenType::ThenType(const ThenType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c), clause_(x.clause_, f, this) {}

ThenType::ThenType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), clause_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
    this->parse(p, f);
  }
}

void ThenType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // clause
    //
    if (n.name() == "clause" && n.namespace_().empty()) {
      ::std::unique_ptr<clause_type> r(clause_traits::create(i, f, this));

      this->clause_.push_back(::std::move(r));
      continue;
    }

    break;
  }
}

ThenType *ThenType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class ThenType(*this, f, c);
}

ThenType &ThenType::operator=(const ThenType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->clause_ = x.clause_;
  }

  return *this;
}

ThenType::~ThenType() {}

// ClauseType
//

ClauseType::ClauseType(const variable_type &variable, const term_type &term)
    : ::xml_schema::type(), variable_(variable, this), term_(term, this), modifier_(this) {}

ClauseType::ClauseType(const ClauseType &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(x, f, c),
      variable_(x.variable_, f, this),
      term_(x.term_, f, this),
      modifier_(x.modifier_, f, this) {}

ClauseType::ClauseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), variable_(this), term_(this), modifier_(this) {
  if ((f & ::xml_schema::flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void ClauseType::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // variable
    //
    if (n.name() == "variable" && n.namespace_().empty()) {
      ::std::unique_ptr<variable_type> r(variable_traits::create(i, f, this));

      if (!variable_.present()) {
        this->variable_.set(::std::move(r));
        continue;
      }
    }

    // term
    //
    if (n.name() == "term" && n.namespace_().empty()) {
      ::std::unique_ptr<term_type> r(term_traits::create(i, f, this));

      if (!term_.present()) {
        this->term_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!variable_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("variable", "");
  }

  if (!term_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("term", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "modifier" && n.namespace_().empty()) {
      this->modifier_.set(modifier_traits::create(i, f, this));
      continue;
    }
  }
}

ClauseType *ClauseType::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class ClauseType(*this, f, c);
}

ClauseType &ClauseType::operator=(const ClauseType &x) {
  if (this != &x) {
    static_cast< ::xml_schema::type &>(*this) = x;
    this->variable_ = x.variable_;
    this->term_ = x.term_;
    this->modifier_ = x.modifier_;
  }

  return *this;
}

ClauseType::~ClauseType() {}

// defuzzifier
//

defuzzifier::defuzzifier() : ::xml_schema::string() {}

defuzzifier::defuzzifier(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

defuzzifier::defuzzifier(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

defuzzifier::defuzzifier(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

defuzzifier::defuzzifier(const defuzzifier &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

defuzzifier::defuzzifier(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

defuzzifier::defuzzifier(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

defuzzifier::defuzzifier(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                         ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

defuzzifier *defuzzifier::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class defuzzifier(*this, f, c);
}

defuzzifier::~defuzzifier() {}

// accumulation
//

accumulation::accumulation() : ::xml_schema::string() {}

accumulation::accumulation(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

accumulation::accumulation(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

accumulation::accumulation(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

accumulation::accumulation(const accumulation &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

accumulation::accumulation(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

accumulation::accumulation(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

accumulation::accumulation(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                           ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

accumulation *accumulation::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class accumulation(*this, f, c);
}

accumulation::~accumulation() {}

// type
//

type::type() : ::xml_schema::string() {}

type::type(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

type::type(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

type::type(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

type::type(const type &x, ::xml_schema::flags f, ::xml_schema::container *c) : ::xml_schema::string(x, f, c) {}

type::type(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

type::type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

type::type(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

type *type::_clone(::xml_schema::flags f, ::xml_schema::container *c) const { return new class type(*this, f, c); }

type::~type() {}

// complement
//

complement::complement(const ::xml_schema::boolean &_xsd_boolean_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type>(_xsd_boolean_base) {}

complement::complement(const complement &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type>(x, f, c) {}

complement::complement(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type>(e, f, c) {}

complement::complement(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type>(a, f, c) {}

complement::complement(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                       ::xml_schema::container *c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type>(s, e, f, c) {}

complement *complement::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class complement(*this, f, c);
}

complement::~complement() {}

// activationMethod
//

activationMethod::activationMethod() : ::xml_schema::string() {}

activationMethod::activationMethod(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

activationMethod::activationMethod(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

activationMethod::activationMethod(const ::xml_schema::string &_xsd_string_base)
    : ::xml_schema::string(_xsd_string_base) {}

activationMethod::activationMethod(const activationMethod &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

activationMethod::activationMethod(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

activationMethod::activationMethod(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

activationMethod::activationMethod(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                                   ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

activationMethod *activationMethod::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class activationMethod(*this, f, c);
}

activationMethod::~activationMethod() {}

// andMethod
//

andMethod::andMethod() : ::xml_schema::string() {}

andMethod::andMethod(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

andMethod::andMethod(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

andMethod::andMethod(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

andMethod::andMethod(const andMethod &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

andMethod::andMethod(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

andMethod::andMethod(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

andMethod::andMethod(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                     ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

andMethod *andMethod::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class andMethod(*this, f, c);
}

andMethod::~andMethod() {}

// orMethod
//

orMethod::orMethod() : ::xml_schema::string() {}

orMethod::orMethod(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

orMethod::orMethod(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

orMethod::orMethod(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

orMethod::orMethod(const orMethod &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

orMethod::orMethod(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

orMethod::orMethod(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

orMethod::orMethod(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

orMethod *orMethod::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class orMethod(*this, f, c);
}

orMethod::~orMethod() {}

// variable
//

variable::variable() : ::xml_schema::string() {}

variable::variable(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

variable::variable(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

variable::variable(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

variable::variable(const variable &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

variable::variable(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

variable::variable(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

variable::variable(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

variable *variable::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class variable(*this, f, c);
}

variable::~variable() {}

// modifier
//

modifier::modifier() : ::xml_schema::string() {}

modifier::modifier(const char *_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

modifier::modifier(const ::std::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

modifier::modifier(const ::xml_schema::string &_xsd_string_base) : ::xml_schema::string(_xsd_string_base) {}

modifier::modifier(const modifier &x, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(x, f, c) {}

modifier::modifier(const ::xercesc::DOMElement &e, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(e, f, c) {}

modifier::modifier(const ::xercesc::DOMAttr &a, ::xml_schema::flags f, ::xml_schema::container *c)
    : ::xml_schema::string(a, f, c) {}

modifier::modifier(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f,
                   ::xml_schema::container *c)
    : ::xml_schema::string(s, e, f, c) {}

modifier *modifier::_clone(::xml_schema::flags f, ::xml_schema::container *c) const {
  return new class modifier(*this, f, c);
}

modifier::~modifier() {}

#include <istream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/sax/std-input-source.hxx>

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::std::string &u, ::xml_schema::flags f,
                                                  const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0,
                                      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::unique_ptr< ::FuzzySystemType>(::fuzzySystem(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::std::string &u, ::xml_schema::error_handler &h,
                                                  ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0,
                                      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr< ::FuzzySystemType>(::fuzzySystem(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::std::string &u, ::xercesc::DOMErrorHandler &h,
                                                  ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr< ::FuzzySystemType>(::fuzzySystem(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, ::xml_schema::flags f,
                                                  const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0,
                                      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::fuzzySystem(isrc, f, p);
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, ::xml_schema::error_handler &h,
                                                  ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0,
                                      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::fuzzySystem(isrc, h, f, p);
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, ::xercesc::DOMErrorHandler &h,
                                                  ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::fuzzySystem(isrc, h, f, p);
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, const ::std::string &sid, ::xml_schema::flags f,
                                                  const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0,
                                      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::fuzzySystem(isrc, f, p);
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, const ::std::string &sid,
                                                  ::xml_schema::error_handler &h, ::xml_schema::flags f,
                                                  const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0,
                                      (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::fuzzySystem(isrc, h, f, p);
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, const ::std::string &sid,
                                                  ::xercesc::DOMErrorHandler &h, ::xml_schema::flags f,
                                                  const ::xml_schema::properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::fuzzySystem(isrc, h, f, p);
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xercesc::InputSource &i, ::xml_schema::flags f,
                                                  const ::xml_schema::properties &p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

  return ::std::unique_ptr< ::FuzzySystemType>(::fuzzySystem(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xercesc::InputSource &i, ::xml_schema::error_handler &h,
                                                  ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr< ::FuzzySystemType>(::fuzzySystem(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xercesc::InputSource &i, ::xercesc::DOMErrorHandler &h,
                                                  ::xml_schema::flags f, const ::xml_schema::properties &p) {
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr< ::FuzzySystemType>(::fuzzySystem(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::xercesc::DOMDocument &doc, ::xml_schema::flags f,
                                                  const ::xml_schema::properties &p) {
  if (f & ::xml_schema::flags::keep_dom) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(
        static_cast< ::xercesc::DOMDocument *>(doc.cloneNode(true)));

    return ::std::unique_ptr< ::FuzzySystemType>(::fuzzySystem(std::move(d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement &e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "fuzzySystem" && n.namespace_() == "") {
    ::std::unique_ptr< ::FuzzySystemType> r(::xsd::cxx::tree::traits< ::FuzzySystemType, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "fuzzySystem", "");
}

::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d,
                                                  ::xml_schema::flags f, const ::xml_schema::properties &) {
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> c(
      ((f & ::xml_schema::flags::keep_dom) && !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument *>(d->cloneNode(true))
          : 0);

  ::xercesc::DOMDocument &doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement &e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::flags::keep_dom) doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d), 0);

  if (n.name() == "fuzzySystem" && n.namespace_() == "") {
    ::std::unique_ptr< ::FuzzySystemType> r(::xsd::cxx::tree::traits< ::FuzzySystemType, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "fuzzySystem", "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
