// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

/**
 * @file
 * @brief Generated from fml.xsd.
 */

#ifndef FML_H
#define FML_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/types.hxx>
#include <xsd/cxx/xml/char-utf8.hxx>
#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/xml/error-handler.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema {
// anyType and anySimpleType.
//

/**
 * @brief C++ type corresponding to the anyType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::type type;

/**
 * @brief C++ type corresponding to the anySimpleType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::simple_type<char, type> simple_type;

/**
 * @brief Alias for the anyType type.
 */
typedef ::xsd::cxx::tree::type container;

// 8-bit
//

/**
 * @brief C++ type corresponding to the byte XML Schema
 * built-in type.
 */
typedef signed char byte;

/**
 * @brief C++ type corresponding to the unsignedByte XML Schema
 * built-in type.
 */
typedef unsigned char unsigned_byte;

// 16-bit
//

/**
 * @brief C++ type corresponding to the short XML Schema
 * built-in type.
 */
typedef short short_;

/**
 * @brief C++ type corresponding to the unsignedShort XML Schema
 * built-in type.
 */
typedef unsigned short unsigned_short;

// 32-bit
//

/**
 * @brief C++ type corresponding to the int XML Schema
 * built-in type.
 */
typedef int int_;

/**
 * @brief C++ type corresponding to the unsignedInt XML Schema
 * built-in type.
 */
typedef unsigned int unsigned_int;

// 64-bit
//

/**
 * @brief C++ type corresponding to the long XML Schema
 * built-in type.
 */
typedef long long long_;

/**
 * @brief C++ type corresponding to the unsignedLong XML Schema
 * built-in type.
 */
typedef unsigned long long unsigned_long;

// Supposed to be arbitrary-length integral types.
//

/**
 * @brief C++ type corresponding to the integer XML Schema
 * built-in type.
 */
typedef long long integer;

/**
 * @brief C++ type corresponding to the nonPositiveInteger XML Schema
 * built-in type.
 */
typedef long long non_positive_integer;

/**
 * @brief C++ type corresponding to the nonNegativeInteger XML Schema
 * built-in type.
 */
typedef unsigned long long non_negative_integer;

/**
 * @brief C++ type corresponding to the positiveInteger XML Schema
 * built-in type.
 */
typedef unsigned long long positive_integer;

/**
 * @brief C++ type corresponding to the negativeInteger XML Schema
 * built-in type.
 */
typedef long long negative_integer;

// Boolean.
//

/**
 * @brief C++ type corresponding to the boolean XML Schema
 * built-in type.
 */
typedef bool boolean;

// Floating-point types.
//

/**
 * @brief C++ type corresponding to the float XML Schema
 * built-in type.
 */
typedef float float_;

/**
 * @brief C++ type corresponding to the double XML Schema
 * built-in type.
 */
typedef double double_;

/**
 * @brief C++ type corresponding to the decimal XML Schema
 * built-in type.
 */
typedef double decimal;

// String types.
//

/**
 * @brief C++ type corresponding to the string XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::string<char, simple_type> string;

/**
 * @brief C++ type corresponding to the normalizedString XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::normalized_string<char, string> normalized_string;

/**
 * @brief C++ type corresponding to the token XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::token<char, normalized_string> token;

/**
 * @brief C++ type corresponding to the Name XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::name<char, token> name;

/**
 * @brief C++ type corresponding to the NMTOKEN XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtoken<char, token> nmtoken;

/**
 * @brief C++ type corresponding to the NMTOKENS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtokens<char, simple_type, nmtoken> nmtokens;

/**
 * @brief C++ type corresponding to the NCName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::ncname<char, name> ncname;

/**
 * @brief C++ type corresponding to the language XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::language<char, token> language;

// ID/IDREF.
//

/**
 * @brief C++ type corresponding to the ID XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::id<char, ncname> id;

/**
 * @brief C++ type corresponding to the IDREF XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idref<char, ncname, type> idref;

/**
 * @brief C++ type corresponding to the IDREFS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idrefs<char, simple_type, idref> idrefs;

// URI.
//

/**
 * @brief C++ type corresponding to the anyURI XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::uri<char, simple_type> uri;

// Qualified name.
//

/**
 * @brief C++ type corresponding to the QName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::qname<char, simple_type, uri, ncname> qname;

// Binary.
//

/**
 * @brief Binary buffer type.
 */
typedef ::xsd::cxx::tree::buffer<char> buffer;

/**
 * @brief C++ type corresponding to the base64Binary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::base64_binary<char, simple_type> base64_binary;

/**
 * @brief C++ type corresponding to the hexBinary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::hex_binary<char, simple_type> hex_binary;

// Date/time.
//

/**
 * @brief Time zone type.
 */
typedef ::xsd::cxx::tree::time_zone time_zone;

/**
 * @brief C++ type corresponding to the date XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date<char, simple_type> date;

/**
 * @brief C++ type corresponding to the dateTime XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date_time<char, simple_type> date_time;

/**
 * @brief C++ type corresponding to the duration XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::duration<char, simple_type> duration;

/**
 * @brief C++ type corresponding to the gDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gday<char, simple_type> gday;

/**
 * @brief C++ type corresponding to the gMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth<char, simple_type> gmonth;

/**
 * @brief C++ type corresponding to the gMonthDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth_day<char, simple_type> gmonth_day;

/**
 * @brief C++ type corresponding to the gYear XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear<char, simple_type> gyear;

/**
 * @brief C++ type corresponding to the gYearMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear_month<char, simple_type> gyear_month;

/**
 * @brief C++ type corresponding to the time XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::time<char, simple_type> time;

// Entity.
//

/**
 * @brief C++ type corresponding to the ENTITY XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entity<char, ncname> entity;

/**
 * @brief C++ type corresponding to the ENTITIES XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entities<char, simple_type, entity> entities;

/**
 * @brief Content order sequence entry.
 */
typedef ::xsd::cxx::tree::content_order content_order;
// Flags and properties.
//

/**
 * @brief Parsing and serialization flags.
 */
typedef ::xsd::cxx::tree::flags flags;

/**
 * @brief Parsing properties.
 */
typedef ::xsd::cxx::tree::properties<char> properties;

// Parsing/serialization diagnostics.
//

/**
 * @brief Error severity.
 */
typedef ::xsd::cxx::tree::severity severity;

/**
 * @brief Error condition.
 */
typedef ::xsd::cxx::tree::error<char> error;

/**
 * @brief List of %error conditions.
 */
typedef ::xsd::cxx::tree::diagnostics<char> diagnostics;

// Exceptions.
//

/**
 * @brief Root of the C++/Tree %exception hierarchy.
 */
typedef ::xsd::cxx::tree::exception<char> exception;

/**
 * @brief Exception indicating that the size argument exceeds
 * the capacity argument.
 */
typedef ::xsd::cxx::tree::bounds<char> bounds;

/**
 * @brief Exception indicating that a duplicate ID value
 * was encountered in the object model.
 */
typedef ::xsd::cxx::tree::duplicate_id<char> duplicate_id;

/**
 * @brief Exception indicating a parsing failure.
 */
typedef ::xsd::cxx::tree::parsing<char> parsing;

/**
 * @brief Exception indicating that an expected element
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_element<char> expected_element;

/**
 * @brief Exception indicating that an unexpected element
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_element<char> unexpected_element;

/**
 * @brief Exception indicating that an expected attribute
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_attribute<char> expected_attribute;

/**
 * @brief Exception indicating that an unexpected enumerator
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_enumerator<char> unexpected_enumerator;

/**
 * @brief Exception indicating that the text content was
 * expected for an element.
 */
typedef ::xsd::cxx::tree::expected_text_content<char> expected_text_content;

/**
 * @brief Exception indicating that a prefix-namespace
 * mapping was not provided.
 */
typedef ::xsd::cxx::tree::no_prefix_mapping<char> no_prefix_mapping;

/**
 * @brief Error handler callback interface.
 */
typedef ::xsd::cxx::xml::error_handler<char> error_handler;

/**
 * @brief DOM interaction.
 */
namespace dom {
/**
 * @brief Automatic pointer for DOMDocument.
 */
using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
/**
 * @brief DOM user data key for back pointers to tree nodes.
 */
const XMLCh *const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
}  // namespace dom
}  // namespace xml_schema

// Forward declarations.
//
class FuzzySystemType;
class KnowledgeBaseType;
class FuzzyVariableType;
class FuzzyTermType;
class OneParamType;
class TwoParamType;
class ThreeParamType;
class FourParamType;
class UserShapeType;
class PointType;
class RuleBaseType;
class MamdaniFuzzyRuleType;
class standardTnormType;
class andMethodType;
class standardTconormType;
class orMethodType;
class connectorType;
class weightType;
class MamdaniRuleBaseType;
class AntecedentType;
class MamdaniConsequentType;
class ThenType;
class ClauseType;
class defuzzifier;
class accumulation;
class type;
class complement;
class activationMethod;
class andMethod;
class orMethod;
class variable;
class modifier;

#include <algorithm>  // std::binary_search
#include <limits>     // std::numeric_limits
#include <memory>     // ::std::unique_ptr
#include <utility>    // std::move
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/list.hxx>
#include <xsd/cxx/xml/char-utf8.hxx>
#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Class corresponding to the %FuzzySystemType schema type.
 *
 * @nosubgrouping
 */
class FuzzySystemType : public ::xml_schema::type {
 public:
  /**
   * @name knowledgeBase
   *
   * @brief Accessor and modifier functions for the %knowledgeBase
   * required element.
   *
   * Fuzzy Concepts Collection
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::KnowledgeBaseType knowledgeBase_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<knowledgeBase_type, char> knowledgeBase_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const knowledgeBase_type &knowledgeBase() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  knowledgeBase_type &knowledgeBase();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void knowledgeBase(const knowledgeBase_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void knowledgeBase(::std::unique_ptr<knowledgeBase_type> p);

  //@}

  /**
   * @name mamdaniRuleBase
   *
   * @brief Accessor and modifier functions for the %mamdaniRuleBase
   * sequence element.
   *
   * Mamdani Fuzzy Rules
   * Collection
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MamdaniRuleBaseType mamdaniRuleBase_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<mamdaniRuleBase_type> mamdaniRuleBase_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef mamdaniRuleBase_sequence::iterator mamdaniRuleBase_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef mamdaniRuleBase_sequence::const_iterator mamdaniRuleBase_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<mamdaniRuleBase_type, char> mamdaniRuleBase_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const mamdaniRuleBase_sequence &mamdaniRuleBase() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  mamdaniRuleBase_sequence &mamdaniRuleBase();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void mamdaniRuleBase(const mamdaniRuleBase_sequence &s);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::id name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type &name() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FuzzySystemType(const knowledgeBase_type &, const name_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  FuzzySystemType(::std::unique_ptr<knowledgeBase_type>, const name_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FuzzySystemType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FuzzySystemType(const FuzzySystemType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FuzzySystemType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FuzzySystemType &operator=(const FuzzySystemType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~FuzzySystemType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<knowledgeBase_type> knowledgeBase_;
  mamdaniRuleBase_sequence mamdaniRuleBase_;
  ::xsd::cxx::tree::one<name_type> name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %KnowledgeBaseType schema type.
 *
 * @nosubgrouping
 */
class KnowledgeBaseType : public ::xml_schema::type {
 public:
  /**
   * @name fuzzyVariable
   *
   * @brief Accessor and modifier functions for the %fuzzyVariable
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FuzzyVariableType fuzzyVariable_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fuzzyVariable_type> fuzzyVariable_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fuzzyVariable_sequence::iterator fuzzyVariable_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fuzzyVariable_sequence::const_iterator fuzzyVariable_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fuzzyVariable_type, char> fuzzyVariable_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fuzzyVariable_sequence &fuzzyVariable() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fuzzyVariable_sequence &fuzzyVariable();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fuzzyVariable(const fuzzyVariable_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  KnowledgeBaseType();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  KnowledgeBaseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  KnowledgeBaseType(const KnowledgeBaseType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual KnowledgeBaseType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  KnowledgeBaseType &operator=(const KnowledgeBaseType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~KnowledgeBaseType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  fuzzyVariable_sequence fuzzyVariable_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FuzzyVariableType schema type.
 *
 * @nosubgrouping
 */
class FuzzyVariableType : public ::xml_schema::type {
 public:
  /**
   * @name fuzzyTerm
   *
   * @brief Accessor and modifier functions for the %fuzzyTerm
   * sequence element.
   *
   * Fuzzy Set
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FuzzyTermType fuzzyTerm_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<fuzzyTerm_type> fuzzyTerm_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef fuzzyTerm_sequence::iterator fuzzyTerm_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef fuzzyTerm_sequence::const_iterator fuzzyTerm_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<fuzzyTerm_type, char> fuzzyTerm_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const fuzzyTerm_sequence &fuzzyTerm() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  fuzzyTerm_sequence &fuzzyTerm();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void fuzzyTerm(const fuzzyTerm_sequence &s);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type &name() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name defuzzifier
   *
   * @brief Accessor and modifier functions for the %defuzzifier
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::defuzzifier defuzzifier_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<defuzzifier_type, char> defuzzifier_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const defuzzifier_type &defuzzifier() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  defuzzifier_type &defuzzifier();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void defuzzifier(const defuzzifier_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void defuzzifier(::std::unique_ptr<defuzzifier_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const defuzzifier_type &defuzzifier_default_value();

  //@}

  /**
   * @name accumulation
   *
   * @brief Accessor and modifier functions for the %accumulation
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::accumulation accumulation_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<accumulation_type, char> accumulation_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const accumulation_type &accumulation() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  accumulation_type &accumulation();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void accumulation(const accumulation_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void accumulation(::std::unique_ptr<accumulation_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const accumulation_type &accumulation_default_value();

  //@}

  /**
   * @name scale
   *
   * @brief Accessor and modifier functions for the %scale
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string scale_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<scale_type> scale_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<scale_type, char> scale_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const scale_optional &scale() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  scale_optional &scale();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void scale(const scale_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void scale(const scale_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void scale(::std::unique_ptr<scale_type> p);

  //@}

  /**
   * @name domainleft
   *
   * @brief Accessor and modifier functions for the %domainleft
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ domainleft_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<domainleft_type, char> domainleft_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const domainleft_type &domainleft() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  domainleft_type &domainleft();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void domainleft(const domainleft_type &x);

  //@}

  /**
   * @name domainright
   *
   * @brief Accessor and modifier functions for the %domainright
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ domainright_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<domainright_type, char> domainright_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const domainright_type &domainright() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  domainright_type &domainright();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void domainright(const domainright_type &x);

  //@}

  /**
   * @name defaultValue
   *
   * @brief Accessor and modifier functions for the %defaultValue
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ defaultValue_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<defaultValue_type, char> defaultValue_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const defaultValue_type &defaultValue() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  defaultValue_type &defaultValue();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void defaultValue(const defaultValue_type &x);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static defaultValue_type defaultValue_default_value();

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::type type_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const type_type &type() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  type_type &type();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void type(const type_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void type(::std::unique_ptr<type_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const type_type &type_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FuzzyVariableType(const name_type &, const domainleft_type &, const domainright_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FuzzyVariableType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FuzzyVariableType(const FuzzyVariableType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FuzzyVariableType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FuzzyVariableType &operator=(const FuzzyVariableType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~FuzzyVariableType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  fuzzyTerm_sequence fuzzyTerm_;
  ::xsd::cxx::tree::one<name_type> name_;
  ::xsd::cxx::tree::one<defuzzifier_type> defuzzifier_;
  static const defuzzifier_type defuzzifier_default_value_;
  ::xsd::cxx::tree::one<accumulation_type> accumulation_;
  static const accumulation_type accumulation_default_value_;
  scale_optional scale_;
  ::xsd::cxx::tree::one<domainleft_type> domainleft_;
  ::xsd::cxx::tree::one<domainright_type> domainright_;
  ::xsd::cxx::tree::one<defaultValue_type> defaultValue_;
  ::xsd::cxx::tree::one<type_type> type_;
  static const type_type type_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FuzzyTermType schema type.
 *
 * @nosubgrouping
 */
class FuzzyTermType : public ::xml_schema::type {
 public:
  /**
   * @name rightLinearShape
   *
   * @brief Accessor and modifier functions for the %rightLinearShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType rightLinearShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rightLinearShape_type> rightLinearShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rightLinearShape_type, char> rightLinearShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rightLinearShape_optional &rightLinearShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  rightLinearShape_optional &rightLinearShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void rightLinearShape(const rightLinearShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void rightLinearShape(const rightLinearShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rightLinearShape(::std::unique_ptr<rightLinearShape_type> p);

  //@}

  /**
   * @name leftLinearShape
   *
   * @brief Accessor and modifier functions for the %leftLinearShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType leftLinearShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<leftLinearShape_type> leftLinearShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<leftLinearShape_type, char> leftLinearShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const leftLinearShape_optional &leftLinearShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  leftLinearShape_optional &leftLinearShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void leftLinearShape(const leftLinearShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void leftLinearShape(const leftLinearShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void leftLinearShape(::std::unique_ptr<leftLinearShape_type> p);

  //@}

  /**
   * @name piShape
   *
   * @brief Accessor and modifier functions for the %piShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType piShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<piShape_type> piShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<piShape_type, char> piShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const piShape_optional &piShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  piShape_optional &piShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void piShape(const piShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void piShape(const piShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void piShape(::std::unique_ptr<piShape_type> p);

  //@}

  /**
   * @name triangularShape
   *
   * @brief Accessor and modifier functions for the %triangularShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ThreeParamType triangularShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<triangularShape_type> triangularShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<triangularShape_type, char> triangularShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const triangularShape_optional &triangularShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  triangularShape_optional &triangularShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void triangularShape(const triangularShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void triangularShape(const triangularShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void triangularShape(::std::unique_ptr<triangularShape_type> p);

  //@}

  /**
   * @name gaussianShape
   *
   * @brief Accessor and modifier functions for the %gaussianShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType gaussianShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<gaussianShape_type> gaussianShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<gaussianShape_type, char> gaussianShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const gaussianShape_optional &gaussianShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  gaussianShape_optional &gaussianShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void gaussianShape(const gaussianShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void gaussianShape(const gaussianShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void gaussianShape(::std::unique_ptr<gaussianShape_type> p);

  //@}

  /**
   * @name rightGaussianShape
   *
   * @brief Accessor and modifier functions for the %rightGaussianShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType rightGaussianShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rightGaussianShape_type> rightGaussianShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rightGaussianShape_type, char> rightGaussianShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rightGaussianShape_optional &rightGaussianShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  rightGaussianShape_optional &rightGaussianShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void rightGaussianShape(const rightGaussianShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void rightGaussianShape(const rightGaussianShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rightGaussianShape(::std::unique_ptr<rightGaussianShape_type> p);

  //@}

  /**
   * @name leftGaussianShape
   *
   * @brief Accessor and modifier functions for the %leftGaussianShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType leftGaussianShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<leftGaussianShape_type> leftGaussianShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<leftGaussianShape_type, char> leftGaussianShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const leftGaussianShape_optional &leftGaussianShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  leftGaussianShape_optional &leftGaussianShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void leftGaussianShape(const leftGaussianShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void leftGaussianShape(const leftGaussianShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void leftGaussianShape(::std::unique_ptr<leftGaussianShape_type> p);

  //@}

  /**
   * @name trapezoidShape
   *
   * @brief Accessor and modifier functions for the %trapezoidShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::FourParamType trapezoidShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<trapezoidShape_type> trapezoidShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<trapezoidShape_type, char> trapezoidShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const trapezoidShape_optional &trapezoidShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  trapezoidShape_optional &trapezoidShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void trapezoidShape(const trapezoidShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void trapezoidShape(const trapezoidShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void trapezoidShape(::std::unique_ptr<trapezoidShape_type> p);

  //@}

  /**
   * @name singletonShape
   *
   * @brief Accessor and modifier functions for the %singletonShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::OneParamType singletonShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<singletonShape_type> singletonShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<singletonShape_type, char> singletonShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const singletonShape_optional &singletonShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  singletonShape_optional &singletonShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void singletonShape(const singletonShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void singletonShape(const singletonShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void singletonShape(::std::unique_ptr<singletonShape_type> p);

  //@}

  /**
   * @name rectangularShape
   *
   * @brief Accessor and modifier functions for the %rectangularShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType rectangularShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<rectangularShape_type> rectangularShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rectangularShape_type, char> rectangularShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const rectangularShape_optional &rectangularShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  rectangularShape_optional &rectangularShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void rectangularShape(const rectangularShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void rectangularShape(const rectangularShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void rectangularShape(::std::unique_ptr<rectangularShape_type> p);

  //@}

  /**
   * @name zShape
   *
   * @brief Accessor and modifier functions for the %zShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType zShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<zShape_type> zShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<zShape_type, char> zShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const zShape_optional &zShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  zShape_optional &zShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void zShape(const zShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void zShape(const zShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void zShape(::std::unique_ptr<zShape_type> p);

  //@}

  /**
   * @name sShape
   *
   * @brief Accessor and modifier functions for the %sShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TwoParamType sShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<sShape_type> sShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<sShape_type, char> sShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sShape_optional &sShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sShape_optional &sShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void sShape(const sShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void sShape(const sShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void sShape(::std::unique_ptr<sShape_type> p);

  //@}

  /**
   * @name userShape
   *
   * @brief Accessor and modifier functions for the %userShape
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::UserShapeType userShape_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<userShape_type> userShape_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<userShape_type, char> userShape_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const userShape_optional &userShape() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  userShape_optional &userShape();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void userShape(const userShape_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void userShape(const userShape_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void userShape(::std::unique_ptr<userShape_type> p);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::id name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type &name() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name complement
   *
   * @brief Accessor and modifier functions for the %complement
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::complement complement_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<complement_type, char> complement_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const complement_type &complement() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  complement_type &complement();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void complement(const complement_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void complement(::std::unique_ptr<complement_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static complement_type complement_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FuzzyTermType(const name_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FuzzyTermType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FuzzyTermType(const FuzzyTermType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FuzzyTermType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FuzzyTermType &operator=(const FuzzyTermType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~FuzzyTermType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  rightLinearShape_optional rightLinearShape_;
  leftLinearShape_optional leftLinearShape_;
  piShape_optional piShape_;
  triangularShape_optional triangularShape_;
  gaussianShape_optional gaussianShape_;
  rightGaussianShape_optional rightGaussianShape_;
  leftGaussianShape_optional leftGaussianShape_;
  trapezoidShape_optional trapezoidShape_;
  singletonShape_optional singletonShape_;
  rectangularShape_optional rectangularShape_;
  zShape_optional zShape_;
  sShape_optional sShape_;
  userShape_optional userShape_;
  ::xsd::cxx::tree::one<name_type> name_;
  ::xsd::cxx::tree::one<complement_type> complement_;

  //@endcond
};

/**
 * @brief Class corresponding to the %OneParamType schema type.
 *
 * @nosubgrouping
 */
class OneParamType : public ::xml_schema::type {
 public:
  /**
   * @name param1
   *
   * @brief Accessor and modifier functions for the %param1
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param1_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param1_type, char> param1_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param1_type &param1() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param1_type &param1();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param1(const param1_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  OneParamType(const param1_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OneParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OneParamType(const OneParamType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual OneParamType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OneParamType &operator=(const OneParamType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~OneParamType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<param1_type> param1_;

  //@endcond
};

/**
 * @brief Class corresponding to the %TwoParamType schema type.
 *
 * @nosubgrouping
 */
class TwoParamType : public ::xml_schema::type {
 public:
  /**
   * @name param1
   *
   * @brief Accessor and modifier functions for the %param1
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param1_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param1_type, char> param1_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param1_type &param1() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param1_type &param1();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param1(const param1_type &x);

  //@}

  /**
   * @name param2
   *
   * @brief Accessor and modifier functions for the %param2
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param2_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param2_type, char> param2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param2_type &param2() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param2_type &param2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param2(const param2_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  TwoParamType(const param1_type &, const param2_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  TwoParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  TwoParamType(const TwoParamType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual TwoParamType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  TwoParamType &operator=(const TwoParamType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~TwoParamType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<param1_type> param1_;
  ::xsd::cxx::tree::one<param2_type> param2_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ThreeParamType schema type.
 *
 * @nosubgrouping
 */
class ThreeParamType : public ::xml_schema::type {
 public:
  /**
   * @name param1
   *
   * @brief Accessor and modifier functions for the %param1
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param1_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param1_type, char> param1_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param1_type &param1() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param1_type &param1();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param1(const param1_type &x);

  //@}

  /**
   * @name param2
   *
   * @brief Accessor and modifier functions for the %param2
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param2_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param2_type, char> param2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param2_type &param2() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param2_type &param2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param2(const param2_type &x);

  //@}

  /**
   * @name param3
   *
   * @brief Accessor and modifier functions for the %param3
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param3_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param3_type, char> param3_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param3_type &param3() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param3_type &param3();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param3(const param3_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ThreeParamType(const param1_type &, const param2_type &, const param3_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ThreeParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThreeParamType(const ThreeParamType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ThreeParamType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThreeParamType &operator=(const ThreeParamType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~ThreeParamType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<param1_type> param1_;
  ::xsd::cxx::tree::one<param2_type> param2_;
  ::xsd::cxx::tree::one<param3_type> param3_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FourParamType schema type.
 *
 * @nosubgrouping
 */
class FourParamType : public ::xml_schema::type {
 public:
  /**
   * @name param1
   *
   * @brief Accessor and modifier functions for the %param1
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param1_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param1_type, char> param1_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param1_type &param1() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param1_type &param1();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param1(const param1_type &x);

  //@}

  /**
   * @name param2
   *
   * @brief Accessor and modifier functions for the %param2
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param2_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param2_type, char> param2_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param2_type &param2() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param2_type &param2();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param2(const param2_type &x);

  //@}

  /**
   * @name param3
   *
   * @brief Accessor and modifier functions for the %param3
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param3_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param3_type, char> param3_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param3_type &param3() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param3_type &param3();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param3(const param3_type &x);

  //@}

  /**
   * @name param4
   *
   * @brief Accessor and modifier functions for the %param4
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ param4_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<param4_type, char> param4_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const param4_type &param4() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  param4_type &param4();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void param4(const param4_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FourParamType(const param1_type &, const param2_type &, const param3_type &, const param4_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FourParamType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FourParamType(const FourParamType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FourParamType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FourParamType &operator=(const FourParamType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~FourParamType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<param1_type> param1_;
  ::xsd::cxx::tree::one<param2_type> param2_;
  ::xsd::cxx::tree::one<param3_type> param3_;
  ::xsd::cxx::tree::one<param4_type> param4_;

  //@endcond
};

/**
 * @brief Class corresponding to the %UserShapeType schema type.
 *
 * @nosubgrouping
 */
class UserShapeType : public ::xml_schema::type {
 public:
  /**
   * @name Point
   *
   * @brief Accessor and modifier functions for the %Point
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::PointType Point_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<Point_type> Point_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Point_sequence::iterator Point_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Point_sequence::const_iterator Point_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Point_type, char> Point_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Point_sequence &Point() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Point_sequence &Point();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void Point(const Point_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  UserShapeType();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  UserShapeType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  UserShapeType(const UserShapeType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual UserShapeType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  UserShapeType &operator=(const UserShapeType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~UserShapeType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  Point_sequence Point_;

  //@endcond
};

/**
 * @brief Class corresponding to the %PointType schema type.
 *
 * @nosubgrouping
 */
class PointType : public ::xml_schema::type {
 public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ x_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<x_type, char> x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const x_type &x() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  x_type &x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void x(const x_type &x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::float_ y_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<y_type, char> y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const y_type &y() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  y_type &y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void y(const y_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  PointType(const x_type &, const y_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  PointType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  PointType(const PointType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual PointType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  PointType &operator=(const PointType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~PointType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<x_type> x_;
  ::xsd::cxx::tree::one<y_type> y_;

  //@endcond
};

/**
 * @brief Class corresponding to the %RuleBaseType schema type.
 *
 * @nosubgrouping
 */
class RuleBaseType : public ::xml_schema::type {
 public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type &name() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name activationMethod
   *
   * @brief Accessor and modifier functions for the %activationMethod
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::activationMethod activationMethod_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<activationMethod_type, char> activationMethod_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const activationMethod_type &activationMethod() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  activationMethod_type &activationMethod();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void activationMethod(const activationMethod_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void activationMethod(::std::unique_ptr<activationMethod_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const activationMethod_type &activationMethod_default_value();

  //@}

  /**
   * @name andMethod
   *
   * @brief Accessor and modifier functions for the %andMethod
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::andMethod andMethod_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<andMethod_type, char> andMethod_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const andMethod_type &andMethod() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  andMethod_type &andMethod();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void andMethod(const andMethod_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void andMethod(::std::unique_ptr<andMethod_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const andMethod_type &andMethod_default_value();

  //@}

  /**
   * @name orMethod
   *
   * @brief Accessor and modifier functions for the %orMethod
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::orMethod orMethod_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<orMethod_type, char> orMethod_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const orMethod_type &orMethod() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  orMethod_type &orMethod();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void orMethod(const orMethod_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void orMethod(::std::unique_ptr<orMethod_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const orMethod_type &orMethod_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  RuleBaseType(const name_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  RuleBaseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  RuleBaseType(const RuleBaseType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual RuleBaseType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  RuleBaseType &operator=(const RuleBaseType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~RuleBaseType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<name_type> name_;
  ::xsd::cxx::tree::one<activationMethod_type> activationMethod_;
  static const activationMethod_type activationMethod_default_value_;
  ::xsd::cxx::tree::one<andMethod_type> andMethod_;
  static const andMethod_type andMethod_default_value_;
  ::xsd::cxx::tree::one<orMethod_type> orMethod_;
  static const orMethod_type orMethod_default_value_;

  //@endcond
};

/**
 * @brief Class corresponding to the %MamdaniFuzzyRuleType schema type.
 *
 * @nosubgrouping
 */
class MamdaniFuzzyRuleType : public ::xml_schema::type {
 public:
  /**
   * @name antecedent
   *
   * @brief Accessor and modifier functions for the %antecedent
   * required element.
   *
   * IF-part of a fuzzy rule
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::AntecedentType antecedent_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<antecedent_type, char> antecedent_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const antecedent_type &antecedent() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  antecedent_type &antecedent();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void antecedent(const antecedent_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void antecedent(::std::unique_ptr<antecedent_type> p);

  //@}

  /**
   * @name consequent
   *
   * @brief Accessor and modifier functions for the %consequent
   * required element.
   *
   * THEN[-ELSE]-part of a fuzzy rule
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MamdaniConsequentType consequent_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<consequent_type, char> consequent_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const consequent_type &consequent() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  consequent_type &consequent();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void consequent(const consequent_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void consequent(::std::unique_ptr<consequent_type> p);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::id name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type &name() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name andMethod
   *
   * @brief Accessor and modifier functions for the %andMethod
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::andMethodType andMethod_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<andMethod_type, char> andMethod_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const andMethod_type &andMethod() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  andMethod_type &andMethod();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void andMethod(const andMethod_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void andMethod(::std::unique_ptr<andMethod_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const andMethod_type &andMethod_default_value();

  //@}

  /**
   * @name orMethod
   *
   * @brief Accessor and modifier functions for the %orMethod
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::orMethodType orMethod_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<orMethod_type, char> orMethod_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const orMethod_type &orMethod() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  orMethod_type &orMethod();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void orMethod(const orMethod_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void orMethod(::std::unique_ptr<orMethod_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const orMethod_type &orMethod_default_value();

  //@}

  /**
   * @name connector
   *
   * @brief Accessor and modifier functions for the %connector
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::connectorType connector_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<connector_type, char> connector_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const connector_type &connector() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  connector_type &connector();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void connector(const connector_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void connector(::std::unique_ptr<connector_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return A read-only (constant) reference to the attribute's
   * default value.
   */
  static const connector_type &connector_default_value();

  //@}

  /**
   * @name weight
   *
   * @brief Accessor and modifier functions for the %weight
   * optional attribute with a default value.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::weightType weight_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<weight_type, char> weight_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const weight_type &weight() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  weight_type &weight();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void weight(const weight_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void weight(::std::unique_ptr<weight_type> p);

  /**
   * @brief Return the default value for the attribute.
   *
   * @return The attribute's default value.
   */
  static weight_type weight_default_value();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  MamdaniFuzzyRuleType(const antecedent_type &, const consequent_type &, const name_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  MamdaniFuzzyRuleType(::std::unique_ptr<antecedent_type>, ::std::unique_ptr<consequent_type>, const name_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MamdaniFuzzyRuleType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MamdaniFuzzyRuleType(const MamdaniFuzzyRuleType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual MamdaniFuzzyRuleType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MamdaniFuzzyRuleType &operator=(const MamdaniFuzzyRuleType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~MamdaniFuzzyRuleType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<antecedent_type> antecedent_;
  ::xsd::cxx::tree::one<consequent_type> consequent_;
  ::xsd::cxx::tree::one<name_type> name_;
  ::xsd::cxx::tree::one<andMethod_type> andMethod_;
  static const andMethod_type andMethod_default_value_;
  ::xsd::cxx::tree::one<orMethod_type> orMethod_;
  static const orMethod_type orMethod_default_value_;
  ::xsd::cxx::tree::one<connector_type> connector_;
  static const connector_type connector_default_value_;
  ::xsd::cxx::tree::one<weight_type> weight_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %standardTnormType
 * schema type.
 */
class standardTnormType : public ::xml_schema::string {
 public:
  /**
   * @brief Underlying enum type.
   */
  enum value { MIN, PROD, BSUM, DRS, EPROD, HPROD, NILMIN };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  standardTnormType(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  standardTnormType(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  standardTnormType(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  standardTnormType(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  standardTnormType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  standardTnormType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  standardTnormType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
                    ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  standardTnormType(const standardTnormType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

#ifdef XSD_CXX11
  standardTnormType &operator=(const standardTnormType &) = default;
#endif

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual standardTnormType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  standardTnormType &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_standardTnormType_convert(); }

  //@cond

 protected:
  value _xsd_standardTnormType_convert() const;

 public:
  static const char *const _xsd_standardTnormType_literals_[7];
  static const value _xsd_standardTnormType_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %andMethodType
 * schema type.
 */
class andMethodType : public ::standardTnormType {
 public:
  /**
   * @brief Underlying enum type.
   */
  typedef ::standardTnormType::value value;

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  andMethodType(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  andMethodType(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  andMethodType(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  andMethodType(const ::standardTnormType &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  andMethodType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  andMethodType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  andMethodType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  andMethodType(const andMethodType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

#ifdef XSD_CXX11
  andMethodType &operator=(const andMethodType &) = default;
#endif

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual andMethodType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  andMethodType &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_andMethodType_convert(); }

  //@cond

 protected:
  value _xsd_andMethodType_convert() const;

 public:
  static const char *const *_xsd_andMethodType_literals_;
  static const value _xsd_andMethodType_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %standardTconormType
 * schema type.
 */
class standardTconormType : public ::xml_schema::string {
 public:
  /**
   * @brief Underlying enum type.
   */
  enum value { MAX, PROBOR, BSUM, DRS, ESUM, HSUM, NILMAX };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  standardTconormType(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  standardTconormType(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  standardTconormType(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  standardTconormType(const ::xml_schema::string &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  standardTconormType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  standardTconormType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  standardTconormType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
                      ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  standardTconormType(const standardTconormType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

#ifdef XSD_CXX11
  standardTconormType &operator=(const standardTconormType &) = default;
#endif

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual standardTconormType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  standardTconormType &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_standardTconormType_convert(); }

  //@cond

 protected:
  value _xsd_standardTconormType_convert() const;

 public:
  static const char *const _xsd_standardTconormType_literals_[7];
  static const value _xsd_standardTconormType_indexes_[7];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %orMethodType
 * schema type.
 */
class orMethodType : public ::standardTconormType {
 public:
  /**
   * @brief Underlying enum type.
   */
  typedef ::standardTconormType::value value;

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  orMethodType(value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  orMethodType(const char *v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  orMethodType(const ::std::string &v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  orMethodType(const ::standardTconormType &v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  orMethodType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  orMethodType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  orMethodType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  orMethodType(const orMethodType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

#ifdef XSD_CXX11
  orMethodType &operator=(const orMethodType &) = default;
#endif

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual orMethodType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  orMethodType &operator=(value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual operator value() const { return _xsd_orMethodType_convert(); }

  //@cond

 protected:
  value _xsd_orMethodType_convert() const;

 public:
  static const char *const *_xsd_orMethodType_literals_;
  static const value _xsd_orMethodType_indexes_[7];

  //@endcond
};

/**
 * @brief Class corresponding to the %connectorType schema type.
 *
 * @nosubgrouping
 */
class connectorType : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  connectorType();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  connectorType(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  connectorType(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  connectorType(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  connectorType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  connectorType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  connectorType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
                ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  connectorType(const connectorType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual connectorType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  connectorType &operator=(const connectorType &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~connectorType();
};

/**
 * @brief Class corresponding to the %weightType schema type.
 *
 * @nosubgrouping
 */
class weightType : public ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type> {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  weightType(const ::xml_schema::float_ &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  weightType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  weightType(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  weightType(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  weightType(const weightType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual weightType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  weightType &operator=(const weightType &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~weightType();
};

/**
 * @brief Class corresponding to the %MamdaniRuleBaseType schema type.
 *
 * @nosubgrouping
 */
class MamdaniRuleBaseType : public ::RuleBaseType {
 public:
  /**
   * @name rule
   *
   * @brief Accessor and modifier functions for the %rule
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MamdaniFuzzyRuleType rule_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<rule_type> rule_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef rule_sequence::iterator rule_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef rule_sequence::const_iterator rule_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<rule_type, char> rule_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const rule_sequence &rule() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  rule_sequence &rule();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void rule(const rule_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  MamdaniRuleBaseType(const name_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MamdaniRuleBaseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MamdaniRuleBaseType(const MamdaniRuleBaseType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual MamdaniRuleBaseType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MamdaniRuleBaseType &operator=(const MamdaniRuleBaseType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~MamdaniRuleBaseType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  rule_sequence rule_;

  //@endcond
};

/**
 * @brief Class corresponding to the %AntecedentType schema type.
 *
 * @nosubgrouping
 */
class AntecedentType : public ::xml_schema::type {
 public:
  /**
   * @name clause
   *
   * @brief Accessor and modifier functions for the %clause
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ClauseType clause_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<clause_type> clause_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef clause_sequence::iterator clause_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef clause_sequence::const_iterator clause_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<clause_type, char> clause_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const clause_sequence &clause() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  clause_sequence &clause();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void clause(const clause_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  AntecedentType();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  AntecedentType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  AntecedentType(const AntecedentType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual AntecedentType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  AntecedentType &operator=(const AntecedentType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~AntecedentType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  clause_sequence clause_;

  //@endcond
};

/**
 * @brief Class corresponding to the %MamdaniConsequentType schema type.
 *
 * @nosubgrouping
 */
class MamdaniConsequentType : public ::xml_schema::type {
 public:
  /**
   * @name then
   *
   * @brief Accessor and modifier functions for the %then
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ThenType then_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<then_type, char> then_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const then_type &then() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  then_type &then();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void then(const then_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void then(::std::unique_ptr<then_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  MamdaniConsequentType(const then_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  MamdaniConsequentType(::std::unique_ptr<then_type>);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MamdaniConsequentType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MamdaniConsequentType(const MamdaniConsequentType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual MamdaniConsequentType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MamdaniConsequentType &operator=(const MamdaniConsequentType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~MamdaniConsequentType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<then_type> then_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ThenType schema type.
 *
 * @nosubgrouping
 */
class ThenType : public ::xml_schema::type {
 public:
  /**
   * @name clause
   *
   * @brief Accessor and modifier functions for the %clause
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ClauseType clause_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<clause_type> clause_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef clause_sequence::iterator clause_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef clause_sequence::const_iterator clause_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<clause_type, char> clause_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const clause_sequence &clause() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  clause_sequence &clause();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it
   * to the sequence. Note that this operation completely changes the
   * sequence and all old elements will be lost.
   */
  void clause(const clause_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ThenType();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ThenType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThenType(const ThenType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ThenType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThenType &operator=(const ThenType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~ThenType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  clause_sequence clause_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ClauseType schema type.
 *
 * @nosubgrouping
 */
class ClauseType : public ::xml_schema::type {
 public:
  /**
   * @name variable
   *
   * @brief Accessor and modifier functions for the %variable
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::variable variable_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<variable_type, char> variable_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const variable_type &variable() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  variable_type &variable();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void variable(const variable_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void variable(::std::unique_ptr<variable_type> p);

  //@}

  /**
   * @name term
   *
   * @brief Accessor and modifier functions for the %term
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string term_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<term_type, char> term_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const term_type &term() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  term_type &term();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void term(const term_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void term(::std::unique_ptr<term_type> p);

  //@}

  /**
   * @name modifier
   *
   * @brief Accessor and modifier functions for the %modifier
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::modifier modifier_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<modifier_type> modifier_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<modifier_type, char> modifier_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const modifier_optional &modifier() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  modifier_optional &modifier();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void modifier(const modifier_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void modifier(const modifier_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void modifier(::std::unique_ptr<modifier_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ClauseType(const variable_type &, const term_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ClauseType(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ClauseType(const ClauseType &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ClauseType *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ClauseType &operator=(const ClauseType &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual ~ClauseType();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<variable_type> variable_;
  ::xsd::cxx::tree::one<term_type> term_;
  modifier_optional modifier_;

  //@endcond
};

/**
 * @brief Class corresponding to the %defuzzifier schema type.
 *
 * @nosubgrouping
 */
class defuzzifier : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  defuzzifier();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  defuzzifier(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  defuzzifier(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  defuzzifier(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  defuzzifier(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  defuzzifier(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  defuzzifier(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  defuzzifier(const defuzzifier &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual defuzzifier *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  defuzzifier &operator=(const defuzzifier &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~defuzzifier();
};

/**
 * @brief Class corresponding to the %accumulation schema type.
 *
 * @nosubgrouping
 */
class accumulation : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  accumulation();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  accumulation(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  accumulation(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  accumulation(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accumulation(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accumulation(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  accumulation(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
               ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  accumulation(const accumulation &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual accumulation *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  accumulation &operator=(const accumulation &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~accumulation();
};

/**
 * @brief Class corresponding to the %type schema type.
 *
 * @nosubgrouping
 */
class type : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  type();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  type(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  type(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  type(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  type(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  type(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  type(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
       ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  type(const type &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual type *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  type &operator=(const type &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~type();
};

/**
 * @brief Class corresponding to the %complement schema type.
 *
 * @nosubgrouping
 */
class complement : public ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type> {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  complement(const ::xml_schema::boolean &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  complement(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  complement(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  complement(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
             ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  complement(const complement &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual complement *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  complement &operator=(const complement &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~complement();
};

/**
 * @brief Class corresponding to the %activationMethod schema type.
 *
 * @nosubgrouping
 */
class activationMethod : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  activationMethod();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  activationMethod(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  activationMethod(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  activationMethod(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  activationMethod(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  activationMethod(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  activationMethod(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
                   ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  activationMethod(const activationMethod &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual activationMethod *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  activationMethod &operator=(const activationMethod &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~activationMethod();
};

/**
 * @brief Class corresponding to the %andMethod schema type.
 *
 * @nosubgrouping
 */
class andMethod : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  andMethod();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  andMethod(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  andMethod(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  andMethod(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  andMethod(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  andMethod(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  andMethod(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
            ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  andMethod(const andMethod &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual andMethod *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  andMethod &operator=(const andMethod &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~andMethod();
};

/**
 * @brief Class corresponding to the %orMethod schema type.
 *
 * @nosubgrouping
 */
class orMethod : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  orMethod();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  orMethod(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  orMethod(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  orMethod(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  orMethod(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  orMethod(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  orMethod(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  orMethod(const orMethod &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual orMethod *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  orMethod &operator=(const orMethod &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~orMethod();
};

/**
 * @brief Class corresponding to the %variable schema type.
 *
 * @nosubgrouping
 */
class variable : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  variable();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  variable(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  variable(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  variable(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  variable(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  variable(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  variable(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  variable(const variable &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual variable *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  variable &operator=(const variable &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~variable();
};

/**
 * @brief Class corresponding to the %modifier schema type.
 *
 * @nosubgrouping
 */
class modifier : public ::xml_schema::string {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required
   * elements and attributes.
   */
  modifier();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  modifier(const char *);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  modifier(const ::std::string &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  modifier(const ::xml_schema::string &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  modifier(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  modifier(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  modifier(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
           ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  modifier(const modifier &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual modifier *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

#ifdef XSD_CXX11
  modifier &operator=(const modifier &) = default;
#endif

  /**
   * @brief Destructor.
   */
  virtual ~modifier();
};

#include <iosfwd>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/sax/InputSource.hpp>

/**
 * @name Parsing functions for the %fuzzySystem document root.
 *
 * Fuzzy System
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::std::string &uri, ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::std::string &uri, ::xml_schema::error_handler &eh,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::std::string &uri, ::xercesc::DOMErrorHandler &eh,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, ::xml_schema::error_handler &eh,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, ::xercesc::DOMErrorHandler &eh,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, const ::std::string &id,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, const ::std::string &id,
                                                  ::xml_schema::error_handler &eh, ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::std::istream &is, const ::std::string &id,
                                                  ::xercesc::DOMErrorHandler &eh, ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xercesc::InputSource &is, ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xercesc::InputSource &is, ::xml_schema::error_handler &eh,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xercesc::InputSource &is, ::xercesc::DOMErrorHandler &eh,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(const ::xercesc::DOMDocument &d, ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties.
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::FuzzySystemType> fuzzySystem(::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d,
                                                  ::xml_schema::flags f = 0,
                                                  const ::xml_schema::properties &p = ::xml_schema::properties());

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif  // FML_H
