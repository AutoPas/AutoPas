/*
 * Copyright 2003-2016 Jeffrey K. Hollingsworth
 *
 * This file is part of Active Harmony.
 *
 * Active Harmony is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Active Harmony is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \page cache Point Caching/Replay layer (cache.so)
 *
 * This processing layer records point/performance pairs in a local
 * cache as they are reported by clients.  If the strategy later
 * generates any points that exist in the cache, this layer will
 * return the associated recorded performance immediately.  Note that
 * any outer layers (include the Harmony server and client) will not
 * be notified upon cache hit.
 *
 * The cache may optionally be initialized by a log file generated
 * from the [Point Logger](\ref logger).
 */

#include "hlayer.h"
#include "session-core.h"
#include "hspace.h"
#include "hpoint.h"
#include "hperf.h"
#include "hutil.h"
#include "hcfg.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

/*
 * Name used to identify this plugin layer.
 * All Harmony plugin layers must define this variable.
 */
const char hplugin_name[] = "cache";

/*
 * Configuration variables used in this plugin.
 * These will automatically be registered by session-core upon load.
 */
const hcfg_info_t hplugin_keyinfo[] = {
    { CFGKEY_CACHE_FILE, NULL, "Log file generated by the Point Logger." },
    { NULL }
};

typedef struct {
    hpoint_t point;
    hperf_t* perf;
    int      idx;
    int      plen;
    int      pcap;
} cache_t;

/*
 * Structure to hold all data needed by an individual search instance.
 *
 * To support multiple parallel search instances, no global variables
 * should be defined or used in this plug-in layer.  They should
 * instead be defined as a part of this structure.
 */
struct hplugin_data {
    hrange_t* dim;
    cache_t*  cache;
    int       cache_len, cache_cap;
    int       hit;
    int       i_cnt;
    int       o_cnt;
    char*     buf;
    int       buflen;
};

/*
 * Internal helper function prototypes.
 */
static cache_t* cache_find(hplugin_data_t* data, htrial_t* trial);
static int      cache_insert(hplugin_data_t* data, htrial_t* trial);
static int      cache_lookup(hplugin_data_t* data, htrial_t* trial);
static int      find_max_strlen(hplugin_data_t* data);
static int      load_logger_file(hplugin_data_t* data, const char* logger);
static int      safe_scanstr(hplugin_data_t* data, FILE* fd, int bounds_idx,
                             const char** match);

/*
 * Allocate memory for a new search task.
 */
hplugin_data_t* cache_alloc(void)
{
    hplugin_data_t* retval = calloc(1, sizeof(*retval));
    if (!retval)
        return NULL;

    return retval;
}

/*
 * Initialize (or re-initialize) data for this search task.
 *
 * Also loads data into cache from a log file if configuration
 * variable CACHE_FILE is defined.
 */
int cache_init(hplugin_data_t* data, hspace_t* space)
{
    const char* filename;

    data->i_cnt = space->len;
    data->o_cnt = hcfg_int(search_cfg, CFGKEY_PERF_COUNT);
    if (data->o_cnt < 1) {
        search_error("Invalid value for " CFGKEY_PERF_COUNT
                     " configuration key");
        return -1;
    }
    data->dim = space->dim;

    for (int i = 0; i < data->cache_cap; ++i) {
        hpoint_fini(&data->cache[i].point);

        for (int j = 0; j < data->cache[i].pcap; ++j)
            hperf_fini(&data->cache[i].perf[j]);
        free(data->cache[i].perf);
    }
    memset(data->cache, 0, data->cache_cap * sizeof(*data->cache));
    data->cache_len = 0;

    filename = hcfg_get(search_cfg, CFGKEY_CACHE_FILE);
    if (filename) {
        data->buflen = find_max_strlen(data) + 1;
        data->buf = malloc(data->buflen * sizeof(char));
        if (!data->buf) {
            search_error("Could not allocate memory for string buffer");
            return -1;
        }

        if (load_logger_file(data, filename) != 0)
            return -1;

        free(data->buf);
    }

    return 0;
}

/*
 * Generate function: look up point in array.
 *
 * Sets status to HFLOW_RETURN with trial's performance set to
 * retrieved value if the point is found.  Otherwise, sets status to
 * HFLOW_ACCEPT (pass point on in plugin workflow).
 */
int cache_generate(hplugin_data_t* data, hflow_t* flow, htrial_t* trial)
{
    // So the client gets a chance to do something when the search is
    // converged not really part of cache, but gemm example client
    // will never terminate or do anything if this isn't present (it
    // never knows when strat is converged)
    //
    if (hcfg_bool(search_cfg, CFGKEY_CONVERGED)) {
        flow->status = HFLOW_ACCEPT;
        return 0;
    }

    if (cache_lookup(data, trial) != 0)
        return -1;

    if (data->hit)
        flow->status = HFLOW_RETURN; // Cache hit.
    else
        flow->status = HFLOW_ACCEPT; // Cache miss.
    return 0;
}

/*
 * Analyze each trial as it passes through the system.  Add the
 * observed point/performance pair to the cache unless it was a result
 * of a cache hit.
 */
int cache_analyze(hplugin_data_t* data, hflow_t* flow, htrial_t* trial)
{
    if (!data->hit) {
        // Insert the performance into the cache.
        if (cache_insert(data, trial) != 0)
            return -1;
    }
    else {
        data->hit = 0; // Clear the cache hit flag.
    }

    flow->status = HFLOW_ACCEPT;
    return 0;
}

/*
 * Free memory associated with this search task.
 */
int cache_fini(hplugin_data_t* data)
{
    for (int i = 0; i < data->cache_cap; ++i) {
        hpoint_fini(&data->cache[i].point);

        for (int j = 0; j < data->cache[i].pcap; ++j)
            hperf_fini(&data->cache[i].perf[j]);
        free(data->cache[i].perf);
    }
    free(data->cache);

    free(data);
    return 0;
}

/*
 * Internal helper function implementation.
 */

cache_t* cache_find(hplugin_data_t* data, htrial_t* trial)
{
    int head = 0;
    int tail = data->cache_len - 1;

    while (head <= tail) {
        int mid    = (head + tail) / 2;
        int retval = hpoint_cmp(&trial->point, &data->cache[ mid ].point);

        if      (retval < 0) tail = mid - 1;
        else if (retval > 0) head = mid + 1;
        else return &data->cache[mid];
    }
    return NULL;
}

int cache_insert(hplugin_data_t* data, htrial_t* trial)
{
    cache_t* hit = cache_find(data, trial);
    if (!hit) {
        // Extend the cache, if necessary.
        if (data->cache_len == data->cache_cap) {
            if (array_grow(&data->cache, &data->cache_cap,
                           sizeof(*data->cache)) != 0)
            {
                search_error("Could not extend cache");
                return -1;
            }
        }

        // Find the appropriate cache slot.
        hit = &data->cache[ data->cache_len ];
        while (data->cache < hit) {
            cache_t* prev = hit - 1;
            if (hpoint_cmp(&trial->point, &prev->point) >= 0)
                break;

            *hit = *prev;
            hit = prev;
        }

        // Initialize the cache slot.
        memset(hit, 0, sizeof(*hit));
        if (hpoint_copy(&hit->point, &trial->point) != 0) {
            search_error("Could not copy trial point into cache");
            return -1;
        }

        ++data->cache_len;
    }

    // Extend the cache slot's performance list, if necessary.
    if (hit->plen == hit->pcap) {
        if (array_grow(&hit->perf, &hit->pcap, sizeof(*hit->perf)) != 0) {
            search_error("Could not extend cache performance list");
            return -1;
        }
    }

    // Add the performance to the end of the list.
    if (hperf_copy(&hit->perf[hit->plen], &trial->perf) != 0) {
        search_error("Could not copy performance into cache");
        return -1;
    }
    ++hit->plen;

    return 0;
}

int cache_lookup(hplugin_data_t* data, htrial_t* trial)
{
    cache_t* hit = cache_find(data, trial);
    if (hit) {
        if (hperf_copy(&trial->perf, &hit->perf[hit->idx]) != 0) {
            search_error("Could not copy performance on cache hit");
            return -1;
        }

        // Increment/wrap the return index.
        hit->idx = (hit->idx + 1) % hit->plen;
        data->hit = 1;
    }
    return 0;
}

/*
 * Search the parameter space for any HVAL_STR dimensions, and return
 * the length of the largest possible string.
 */
int find_max_strlen(hplugin_data_t* data)
{
    int max = 0;

    for (int i = 0; i < data->i_cnt; ++i) {
        if (data->dim[i].type == HVAL_STR) {
            for (int j = 0; j < data->dim[i].bounds.e.len; ++j) {
                int len = strlen(data->dim[i].bounds.e.set[j]) + 1;
                if (max < len)
                    max = len;
            }
        }
    }
    return max;
}

/*
 * Initialize the in-memory cache using a log file generated from the
 * logger layer during a prior tuning session.
 *
 * Note: This function must be kept in sync with the output routines
 *       of the logger layer.
 */
#define SKIP_PATTERN(fp, pattern)                                       \
    if (fscanf(fp, pattern) == EOF) {                                   \
        search_error("Error parsing logger file: Invalid input");       \
        return -1;                                                      \
    }
int load_logger_file(hplugin_data_t* data, const char* filename)
{
    int ret;
    FILE* fp = NULL;
    htrial_t trial = {{0}};

    if (hpoint_init((hpoint_t*) &trial.point, data->i_cnt) != 0) {
        search_error("Could not allocate memory for temporary point");
        goto error;
    }
    ((hpoint_t*) &trial.point)->len = data->i_cnt;

    if (hperf_init(&trial.perf, data->o_cnt) != 0) {
        search_error("Could not allocate memory for temporary perf");
        goto error;
    }
    trial.perf.len = data->o_cnt;

    fp = fopen(filename, "r");
    if (!fp) {
        search_error("Could not open log file");
        goto error;
    }

    char c;
    while (fscanf(fp, " %c", &c) != EOF) {
        // Skip any line that doesn't start with 'P'.
        if (c != 'P') {
            SKIP_PATTERN(fp, "%*[^\n] ");
            continue;
        }
        SKIP_PATTERN(fp, "oint #%*d: ( ");

        // Parse point data.
        for (int i = 0; i < data->i_cnt; ++i) {
            hval_t* v = &trial.point.term[i];

            if (i > 0) SKIP_PATTERN(fp, " ,");

            v->type = data->dim[i].type;
            switch (data->dim[i].type) {
            case HVAL_INT:  ret = fscanf(fp, "%ld", &v->value.i); break;
            case HVAL_REAL: ret = fscanf(fp, "%*f[%la]", &v->value.r); break;
            case HVAL_STR:  ret = safe_scanstr(data, fp, i,
                                               &v->value.s); break;
            default:
                search_error("Invalid point value type");
                goto error;
            }

            if (ret != 1) {
                search_error("Error parsing point data from logfile");
                goto error;
            }
        }

        // Parse performance data.
        SKIP_PATTERN(fp, " ) => (");
        for (int i = 0; i < data->o_cnt; ++i) {
            if (i > 0) SKIP_PATTERN(fp, " ,");
            if (fscanf(fp, " %*f[%la]", &trial.perf.obj[i]) != 1) {
                search_error("Error parsing performance data from logfile");
                goto error;
            }
        }

        // Discard the rest of the line after the right parenthesis.
        if (fscanf(fp, " %c%*[^\n]", &c) != 1 || c != ')') {
            search_error("Error parsing point data from logfile");
            goto error;
        }

        if (cache_insert(data, &trial) != 0) {
            search_error("Could insert log data into cache");
            goto error;
        }
    }
    ret = 0;
    goto cleanup;

  error:
    ret = -1;

  cleanup:
    if (fp) fclose(fp);
    hpoint_fini((hpoint_t*) &trial.point);
    hperf_fini(&trial.perf);

    return ret;
}

/*
 * Parse a double-quoted string value from a file stream.  Static
 * variables buf and buflen must be initialized prior to use.
 *
 * Return values designed to match scanf family.
 */
int safe_scanstr(hplugin_data_t* data, FILE* fp, int bounds_idx,
                 const char** match)
{
    int i;
    range_enum_t* bounds = &data->dim[bounds_idx].bounds.e;

    SKIP_PATTERN(fp, " \"");
    for (i = 0; i < data->buflen; ++i) {
        int c = fgetc(fp);

        if (c == '\\')
            c = fgetc(fp);
        if (c == '\"' || c == EOF)
            break;

        data->buf[i] = (char)c;
    }
    if (i == data->buflen) {
        search_error("Input HVAL_STR overrun");
        return EOF;
    }
    data->buf[i] = '\0';

    for (i = 0; i < bounds->len; ++i) {
        if (strcmp(data->buf, bounds->set[i]) == 0)
            break;
    }
    if (i == bounds->len) {
        search_error("Invalid HVAL_STR value");
        return 0;
    }

    *match = bounds->set[i];
    return 1;
}
