        - # using ..Properties, ..AutoPasM, ..AIterators
        - # using ..Simulator.AutoPasInterface, ..Simulator.Iterators
        - 
        - 
        - function getNp(apc)
        -     np0 = 0
        -     iter = AutoPasInterface.begin(apc, IteratorBehavior(ownedOrHalo))
        -     while isValid(iter)
        -         np0 += 1
        -         Simulator.Iterators.:++(iter)
        -     end
        -     return np0
        - end
        - 
        - 
        - function parseInput(inputParameters)
        - 
        -     # create ParticlePropertiesLibrary and generate particles
        0     particlePropertiesLibrary = Properties.ParticlePropertiesLibrary{Float64, UInt}(inputParameters.cutoff)
        0     particles = initPplAndParticles(particlePropertiesLibrary, inputParameters.objects)
        - 
        -     # create AutoPas container and initialize all values
        0     autoPasContainer = initAutoPasContainer(inputParameters)
        0     Properties.calculateMixingCoefficients(particlePropertiesLibrary)
        - 
        -     # add particles to AutoPas container
        -     index = 0
        0     for particle in particles
        0         addParticle(autoPasContainer, particle)
        0         index += 1
        0     end
      256     println("added " * string(index) * " particles")
        - 
        -     # println("particles in container: ", getNp(autoPasContainer))
        - 
        0     return autoPasContainer, particlePropertiesLibrary
        - end
        - 
        - function initPplAndParticles(ppl, objects)
        - 
       96     particles = []
        -     index = 0
        0     for particleObject in objects
       96         Properties.addType(ppl, particleObject.particleType, particleObject.particleEpsilon, particleObject.particleSigma, particleObject.particleMass)
        -         
       64         generatedParticles, index = generateObject(particleObject, index)
      512         append!(particles, generatedParticles)
        0     end
        0     return particles
        - end
        - 
        - function initAutoPasContainer(inputParameters)
        - 
        0     apc = AutoPas{Particles.MoleculeJ{Float64}}()
        - 
        -     # add setter with new type
        -     # setCellS
        0     setAllowedContainers(apc, inputParameters.container)
        0     setAllowedDataLayouts(apc, inputParameters.dataLayout)
        0     setAllowedNewton3Options(apc, inputParameters.newton3)
        0     setAllowedTraversals(apc, inputParameters.traversal)
        -     # AutoPasM.setAllowedLoadEstimators(apc, inputparameters._configuration.loadEstimatorOptions.value);
        0     setBoxMin(apc, inputParameters.boxMin)
        0     setBoxMax(apc, inputParameters.boxMax)
        0     setCutoff(apc, inputParameters.cutoff)
        -     # AutoPasM.setRelativeOptimumRange(_configuration.relativeOptimumRange.value);
        -     # AutoPasM.setMaxTuningPhasesWithoutTest(_configuration.maxTuningPhasesWithoutTest.value);
        -     # AutoPasM.setRelativeBlacklistRange(_configuration.relativeBlacklistRange.value);
        -     # AutoPasM.setEvidenceFirstPrediction(_configuration.evidenceFirstPrediction.value);
        -     # AutoPasM.setExtrapolationMethodOption(_configuration.extrapolationMethodOption.value);
        -     # AutoPasM.setNumSamples(_configuration.tuningSamples.value)
        -     # AutoPasM.setMaxEvidence(_configuration.tuningMaxEvidence.value)
        0     setSelectorStrategy(apc, inputParameters.selectorStrategy)
        0     setTuningInterval(apc, inputParameters.tuningInterval)
        0     setTuningStrategyOption(apc, inputParameters.tuningStrategy)
        0     setMPIStrategy(apc, inputParameters.mpiStrategy)
        -     # AutoPasM.setMPITuningMaxDifferenceForBucket(_configuration.MPITuningMaxDifferenceForBucket.value);
        -     # AutoPasM.setMPITuningWeightForMaxDensity(_configuration.MPITuningWeightForMaxDensity.value);
        -     # AutoPasM.setVerletClusterSize(apc, inputParameters.verletClusterSize)
        -     # AutoPasM.setVerletRebuildFrequency(apc, inputParameters.verletRebuildFrequency)
        -     # AutoPasM.setVerletSkinPerTimestep(apc, inputParameters.verletSkinRadiusPerTimestep)
        -     # AutoPasM.setAcquisitionFunction(_configuration.acquisitionFunctionOption.value);
        0     init(apc)
        0     return apc
        - end
